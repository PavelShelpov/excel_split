=== PROJECT STRUCTURE ===

./
├── config.py
├── iteration_log.txt
├── logging_config.py
├── main.py
├── cli/
│   ├── interface.py
│   ├── __init__.py
├── core/
│   ├── processing.py
│   ├── __init__.py
├── excel_utils/
│   ├── analysis.py
│   ├── common.py
│   ├── filtering.py
│   ├── formatting.py
│   ├── workbook.py
│   ├── __init__.py
├── gui/
│   ├── placeholder.py
│   ├── __init__.py
├── tests/
│   ├── test_analysis.py
│   ├── test_filename_shortening.py
│   ├── test_filtering.py
│   ├── test_imports.py
│   ├── test_module_initialization.py
│   ├── test_special_formats.py
│   ├── test_table_formatting.py


=== FILE CONTENTS ===


─── FILE: config.py ───

# Конфигурация проекта
# Будет расширена в будущих итерациях

MAX_SCAN_ROWS = 10
DEFAULT_FILE_EXTENSION = '.xlsx'

─── FILE: iteration_log.txt ───

Итерация #51
	Ключевые изменения:
		Заменены импорты из пакета на прямые импорты из модулей для устранения циклических зависимостей
		Добавлена отладочная информация в __init__.py для диагностики проблем с инициализацией
		Добавлен тест проверки инициализации всех модулей и доступности критических функций
	Решенные проблемы:
		Устранена ошибка ImportError: cannot import name 'generate_short_filename' from 'excel_utils'
		Обеспечена корректная инициализация всех модулей проекта
		Добавлена диагностика для выявления подобных проблем в будущем
	Проблемы:
		Требуется дальнейшее рефакторинг для полного устранения циклических зависимостей
		Тесты провалены:
			(.venv) PS C:\Users\shelp\projects\excel_split> python -m unittest discover
			Failed to initialize excel_utils package: name 'logging' is not defined
			Failed to initialize excel_utils package: name 'logging' is not defined
			EE
			======================================================================
			ERROR: cli (unittest.loader._FailedTest.cli)
			----------------------------------------------------------------------
			ImportError: Failed to import test module: cli
			Traceback (most recent call last):
			File "C:\Users\shelp\AppData\Local\Programs\Python\Python313\Lib\unittest\loader.py", line 429, in _find_test_path     
				package = self._get_module_from_name(name)
			File "C:\Users\shelp\AppData\Local\Programs\Python\Python313\Lib\unittest\loader.py", line 339, in _get_module_from_name
				__import__(name)
				~~~~~~~~~~^^^^^^
			File "C:\Users\shelp\projects\excel_split\cli\__init__.py", line 2, in <module>
				from .interface import main
			File "C:\Users\shelp\projects\excel_split\cli\interface.py", line 1, in <module>
				from core.processing import process_file
			File "C:\Users\shelp\projects\excel_split\core\__init__.py", line 2, in <module>
				from .processing import process_file
			File "C:\Users\shelp\projects\excel_split\core\processing.py", line 3, in <module>
				from excel_utils.analysis import get_all_sheets_headers, analyze_column
			File "C:\Users\shelp\projects\excel_split\excel_utils\__init__.py", line 21, in <module>
				logger = logging.getLogger('excel_splitter')
						^^^^^^^
			NameError: name 'logging' is not defined. Did you forget to import 'logging'?


			======================================================================
			ERROR: excel_utils (unittest.loader._FailedTest.excel_utils)
			----------------------------------------------------------------------
			ImportError: Failed to import test module: excel_utils
			Traceback (most recent call last):
			File "C:\Users\shelp\AppData\Local\Programs\Python\Python313\Lib\unittest\loader.py", line 429, in _find_test_path     
				package = self._get_module_from_name(name)
			File "C:\Users\shelp\AppData\Local\Programs\Python\Python313\Lib\unittest\loader.py", line 339, in _get_module_from_name
				__import__(name)
				~~~~~~~~~~^^^^^^
			File "C:\Users\shelp\projects\excel_split\excel_utils\__init__.py", line 21, in <module>
				logger = logging.getLogger('excel_splitter')
						^^^^^^^
			NameError: name 'logging' is not defined. Did you forget to import 'logging'?


			----------------------------------------------------------------------
			Ran 2 tests in 0.000s

			FAILED (errors=2)

Итерация #50
	Ключевые изменения:
		Исправлен импорт функции generate_short_filename через обновление __init__.py
		Добавлен тест на проверку корректности импортов всех модулей
		Улучшена документация экспортируемых функций
		Проверена доступность всех публичных функций через пакетный импорт
	Решенные проблемы:
		Устранена ошибка ImportError: cannot import name 'generate_short_filename'
		Гарантирован доступ ко всем необходимым функциям через пакетный импорт
		Добавлены тесты для предотвращения подобных ошибок в будущем
	Проблемы:
		Требуется дальнейшее расширение тестового покрытия
		Нужно рассмотреть автоматизацию проверки импортов через статический анализ
		Провалены тесты:
			ImportError: Failed to import test module: cli
			ImportError: cannot import name 'generate_short_filename' from 'excel_utils'

Итерация #49
	Ключевые изменения:
		Исправлена ошибка с TableStyleInfo через использование только поддерживаемых параметров
		Реализовано сокращение длинных названий категорий по правилам:
			- Для одного слова: первые 3 буквы
			- Для двух и более слов: первая буква каждого слова
		Добавлена проверка длины пути к файлу и автоматическое сокращение при необходимости
		Добавлены тесты для проверки обработки длинных имен файлов
	Решенные проблемы (не может быть проверено):
		Устранена ошибка "TableStyleInfo.__init__() got an unexpected keyword argument 'showRowHeaders'"
		Устранена проблема с неправильным открытием файлов с длинными именами
		Добавлено сокращение длинных названий категорий в имена файлов
		Реализована проверка длины пути к файлу
	Проблемы:
		Требуется проверка совместимости с очень старыми версиями Excel
		Нужно добавить настройки стиля таблиц для пользовательской кастомизации
		Требуется добавить поддержку специфических таблиц (например, с итогами)
		ImportError: cannot import name 'generate_short_filename' from 'excel_utils'

Итерация #48
	Ключевые изменения:
		Реализована адаптивная обработка условного форматирования для разных версий openpyxl
		Убраны автофильтры и добавлено форматирование данных как таблиц
		Оптимизировано логирование для уменьшения количества предупреждений
		Добавлены тесты для проверки форматирования таблиц
	Решенные проблемы (не может быть проверено):
			Устранены ошибки копирования условного форматирования
			Убраны избыточные предупреждения о неизвестных стилях
			Добавлено форматирование данных как таблиц в результирующих файлах
			Убраны автофильтры из результирующих файлов
	Проблемы:
		Требуется проверка совместимости с очень старыми версиями Excel
		Нужно добавить настройки стиля таблиц для пользовательской кастомизации
		Требуется добавить поддержку специфических таблиц (например, с итогами)
		Созданные файлы с длинными названиями не открываются
		КРИТИЧЕСКАЯ ОШИБКА: TableStyleInfo.__init__() got an unexpected keyword argument 'showRowHeaders'
	Дополнения:
		Названия всех категорий в названии, кроме последнего (или первого, если категория одна), необходимо сокращать.
			Например: 'Аппарат управления' -> 'Аппарат управления', 'Аппарат управления_Управление развития_Отдел разработки' -> 'АпУ_УпР_Отдел разработки'

Итерация #47
	Ключевые изменения:
		Добавлена обработка неизвестных стилей (SAPBEXstdItem) с логированием вместо ошибок
		Переработана логика копирования условного форматирования для совместимости с разными версиями openpyxl
		Добавлены типизированные аннотации и улучшена документация кода
		Добавлены тесты для обработки специальных форматов и условного форматирования
	Решенные проблемы:
		Устранена ошибка "SAPBEXstdItem is not a known style"
		Устранены проблемы с анализом кода Pylance
		Добавлены дополнительные тесты для проверки обработки специальных форматов
	Проблемы:
		Множество предупреждений Unknown style detected and ignored for data cell
		Условное форматирование не переносится:
			Error copying conditional formatting: 'ConditionalFormatting' object has no attribute '_range'
			Failed to copy conditional formatting: 'ConditionalFormatting' object has no attribute 'type'
	Дополнения:
		Убрать добавление автофильров в результирующие файлы
		Форматировать диапазоны данных в итоговых файлах как таблицы

Итерация #46
	Ключевые изменения:
		Исправлены все импорты validate_row по проекту
		Добавлено детальное логирование для отслеживания работы фильтрации
		Улучшена обработка пустых фильтров и случаев без совпадений
		Добавлены тесты для проверки работы фильтрации
	Решенные проблемы:
		Устранена ошибка "name 'validate_row' is not defined"
		Исправлена неправильная обработка случаев без совпадений
		Добавлены проверки на пустые фильтры
		Программа отрабатывает полный цикл файлы создаются
	Возникшие критические проблемы:
		Нет
	Возникшие предупреждения:
		Терминал:
			Error copying data cell at row 1-2034, col 1-11: SAPBEXstdItem is not a known style
			Error copying conditional formatting: 'ConditionalFormatting' object has no attribute '_range'
			Failed to copy conditional formatting: 'ConditionalFormatting' object has no attribute '_range'
		processing.py 
			Доступ к "analyze_column" не осуществляется Pylance
			Доступ к "get_all_combinations" не осуществляется Pylance
	Требуемые дополнения (обновления):
		Требуется добавить больше тестов для обработки специальных типов данных
		Нужно настроить CI/CD для автоматического запуска тестов

Итерация #45
	Ключевые изменения:
		Полностью устранены циклические зависимости между модулями
		Вынесена функция validate_row в отдельный модуль common
		Добавлены тесты на проверку корректности импортов
		Добавлены логи для отслеживания процесса загрузки модулей
	Проблемы решены:
		Исправлена ошибка импорта, приложение запускается корректно
		Устранены циклические зависимости между analysis.py и filtering.py
		Добавлены тесты для проверки загрузки всех модулей
	Возникшие проблемы:
		if not validate_row([cell.value for cell in row], headers, header_row_idx, filters):
			"validate_row" не определено Pylancereport UndefinedVariable
			(function) validate_row: Any
		Error processing row 1-2059: name 'validate_row' is not defined
		No data matched the filters, file not created
		Warning: No files created (no data matched the filters)

Итерация #44
	Ключевые изменения:
		Исправлены имена инициализационных файлов (init.py -> __init__.py)
		Устранены циклические зависимости между модулями
		Добавлена система логирования с базовой конфигурацией
		Добавлена структура для unit-тестов с первым тестом
	Проблемы решены:
		Исправлена ошибка импорта, приложение запускается корректно
			НЕ РЕШЕНО:
				Traceback (most recent call last):
					File "c:\Users\Pavel.Shelpov2\projects\excel_split\main.py", line 2, in <module>
						from cli.interface import main as cli_main
					File "c:\Users\Pavel.Shelpov2\projects\excel_split\cli\__init__.py", line 2, in <module>
						from .interface import main
					File "c:\Users\Pavel.Shelpov2\projects\excel_split\cli\interface.py", line 1, in <module>
						from core.processing import process_file
					File "c:\Users\Pavel.Shelpov2\projects\excel_split\core\__init__.py", line 2, in <module>
						from .processing import process_file
					File "c:\Users\Pavel.Shelpov2\projects\excel_split\core\processing.py", line 3, in <module>
						from excel_utils import (
						...<6 lines>...
						)
					File "c:\Users\Pavel.Shelpov2\projects\excel_split\excel_utils\__init__.py", line 3, in <module>
						from .filtering import validate_row, get_all_combinations, select_categories_sequentially
					ImportError: cannot import name 'validate_row' from 'excel_utils.filtering' (c:\Users\Pavel.Shelpov2\projects\excel_split\excel_utils\filtering.py)
		Добавлены логи для отслеживания операций
		Добавлена базовая структура для тестирования
	Проблемы:
		Требуется добавить больше unit-тестов для ключевых функций
		Нужно настроить CI/CD для автоматического запуска тестов

Итерация #43
    Ключевые изменения:
        Внедрена модульная структура проекта: разделение на логические модули (excel_utils, cli, core, gui)
        Создана основа для расширения: добавлены заготовки для будущего GUI
        Улучшена поддерживаемость: добавлены типизированные аннотации, оптимизированы импорты
    Проблемы:
        Требуется добавление системы логирования для отслеживания операций
        Нужно внедрить unit-тесты для критически важных функций
		Работоспособность нарушена:
			Traceback (most recent call last):
				File "c:\Users\Pavel.Shelpov2\projects\excel_split\main.py", line 2, in <module>
					from cli.interface import main as cli_main
				File "c:\Users\Pavel.Shelpov2\projects\excel_split\cli\interface.py", line 1, in <module>
					from core.processing import process_file
				File "c:\Users\Pavel.Shelpov2\projects\excel_split\core\processing.py", line 3, in <module>
					from excel_utils import (
					...<7 lines>...
					)
			ImportError: cannot import name 'get_all_sheets_headers' from 'excel_utils' (unknown location)

Итерация #42
	Ключевые изменения:
		Убрана поддержка .xlsm, все файлы сохраняются как .xlsx.
		Исправлено копирование условного форматирования для всех типов правил.
		Упрощена логика сохранения файлов.
	Проблемы:
		Нет возможности вернуться и выбрать другой файл после его выбора, только через ctrl+c
		Многоуровневая фильтрация не дает возможности выбрать все уровни разом, а только точечно

Итерация #41
	Ключевые изменения:
		Добавлена опция выбора всех комбинаций с подтверждением.
		Исправлено копирование условного форматирования для .xlsm файлов.
		Ограничена область автофильтра только строкой заголовков.
	Проблемы:
		Условное форматирование не переносится

Итерация #40
	Ключевые изменения:
		Полностью переработана логика выбора категорий с использованием рекурсии для правильного отображения вариантов.
		Исправлено сохранение .xlsm файлов с макросами.
		Добавлена обработка частичных уровней фильтрации
	Проблемы:
		В результаты xlsm не переносится условное форматирование
		Кнопки фильтров растягиваются дальше заголовков по строке

Итерация #39
	Изменено:
		Полностью переработана логика генерации комбинаций фильтров для множественного выбора.
		Исправлено сохранение .xlsm файлов с макросами.
		Добавлена обработка частичных уровней фильтрации.
	Проблемы:
		Проблема с комбинациями категорий не исправлена
		Error: Error during filtering: Workbook.__init__() got an unexpected keyword argument 'keep_vba'

Итерация #38
	Изменено:
		Убран недопустимый параметр keep_vba при создании нового файла.
		Переработана логика выбора категорий для отображения вариантов для каждой комбинации.
		Исправлено зацикливание при выборе последней колонки.
	Выявленные проблемы:
		Проблема с комбинациями категорий не исправлена:
			Выбираются две колонки, в первой выбираются две категории, для второй выбираются all, ожидается, что для каждой из первых двух категорий будут подобраны все комбинации из второй, чего не проиходит

Итерация #37
	Изменено:
		Удален недопустимый параметр keep_vba при создании нового файла.
		Добавлена корректная обработка макросов для .xlsm файлов через параметр при загрузке.
		Улучшена логика сохранения макросов при работе с .xlsm файлами.
	Выявленные проблемы:
		Не решено: Error: Error during filtering: Workbook.__init__() got an unexpected keyword argument 'keep_vba' после выбора последней категории в любых файлах
		Выбор категорий уровнями ниже осуществляется некорректно, ищет только пересечения с уровнями выше, а нужно учитывать все комбинации.

Итерация #36
	Изменено:
		Добавлена проверка видимости листов при анализе.
		Исправлена ошибка с keep_vba для .xlsx файлов.
		Улучшена обработка скрытых листов на всех этапах.
	Выявленные проблемы:
		Error: Error during filtering: Workbook.__init__() got an unexpected keyword argument 'keep_vba' после выбора последней категории в любых файлах

Итерация #35
	Добавлена проверка наличия данных на листе перед добавлением в результирующий файл.
	Добавлен автофильтр в строку заголовков результирующих файлов.
	Добавлена поддержка .xlsm файлов с сохранением макросов.

Итерация #34
	Исправлена обработка ключевого слова "all" в выборе категорий
	Улучшена логика генерации комбинаций для множественного выбора
	Создаются файлы для всех выбранных комбинаций, включая частичные уровни

Итерация #33
	Создана отдельная функция process_file() для обработки одного файла
	Упрощен главный цикл программы
	Исправлено зацикливание при выборе последней колонки
	Добавлена обработка ошибок на каждом этапе

Итерация #32
	Удален запрос подтверждения после успешного выполнения
	Программа автоматически возвращается к выбору файла после успешной обработки
	Улучшена обработка ошибок для бесшовного перехода к следующей итерации

Итерация #31
	Добавлено отображение колонок в нумерованном списке
	Улучшена обработка ошибок ввода с возвратом к предыдущему шагу
	Добавлена возможность отмены шага и исправления предыдущего ввода
	Исправлена ошибка UnboundLocalError при прерывании через Ctrl+C
	Улучшена логика создания файлов для всех уровней комбинаций

Итерация #30
	Разделение на два режима: анализ данных в read-only, создание файлов в полном режиме
	Добавлены проверки на наличие атрибутов column_dimensions и row_dimensions
	Улучшена обработка исключений для предотвращения повреждения оригинального файла

Итерация #29
	Восстановлен режим read_only=False с безопасным управлением ресурсами
	Добавлены контекстные менеджеры для гарантированного закрытия файлов
	Улучшена обработка исключений для предотвращения повреждения оригинального файла

Итерация #28
	Последовательный выбор категорий: пользователь последовательно выбирает категории для каждой колонки
	Динамический анализ доступных категорий: на каждом этапе отображаются только доступные варианты
	Оптимизация производительности: кэширование промежуточных результатов

Итерация #27
	Восстановлена оригинальная фильтрация для одного уровня
	Иерархическая обработка выделена в отдельную функцию
	Добавлена возможность отмены операции через Ctrl+C

Итерация #26
	Переключение на read_only=True для загрузки исходного файла
	Добавлена явная проверка на существование целевого файла перед сохранением
	Улучшена обработка исключений для гарантированного закрытия файлов

Итерация #25
	Восстановлено полное копирование стилей (цвета, шрифты, границы)
	Сохранение ширины столбцов и высоты строк
	Исправлено копирование объединенных ячеек

Итерация #24
	Последовательная обработка уровней сверху вниз
	Итеративный подход вместо рекурсии
	Проверка данных перед созданием файлов

Итерация #23
	Упрощенная логика фильтрации при выборе одной колонки
	Добавлена опция выбора нескольких категорий
	Генерация имен файлов с префиксами уровней

Итерация #22
	Восстановлено полное копирование стилей (цвета, шрифты, границы)
	Сохранение ширины столбцов и высоты строк
	Исправлено копирование объединенных ячеек

Итерация #21
	Устранена проблема с техническими строками ниже таблицы
	Оптимизирована производительность за счет упрощения копирования стилей
	Восстановлена базовая фильтрация для одной колонки

Итерация #20
	Восстановлена оригинальная фильтрация для одного уровня
	Иерархическая обработка выделена в отдельную функцию
	Добавлена возможность отмены операции через Ctrl+C

Итерация #19
	Последовательная обработка уровней сверху вниз
	Итеративный подход вместо рекурсии
	Проверка данных перед созданием файлов

Итерация #18
	Поддержка выбора нескольких колонок через запятую
	Создание файлов для каждого уровня иерархии
	Формирование имен файлов с префиксами всех предыдущих уровней

Итерация #17
	Добавлена поддержка множественного выбора категорий через запятую и ключевое слово "all"
	Генерация имен файлов с суффиксом категории и защитой от недопустимых символов
	Циклическая обработка каждой категории с созданием отдельных файлов

Итерация #16
	Устранены предупреждения через импорт copy и замену .copy()
	Сохранение числовых форматов (даты, валюта) через number_format
	Полная совместимость с openpyxl без предупреждений

Итерация #15
	Полное сохранение форматирования: стили, объединения, ширина/высота
	Сохранение технических строк выше и ниже таблицы
	Создание нового файла "с нуля" без внешних зависимостей

Итерация #14
	Создание чистого файла без внешних зависимостей через Workbook()
	Копирование только значений ячеек (без форматирования)
	Гарантированная совместимость с Excel

Итерация #13
	Условное удаление временного файла только при изменении расширения
	Обработка регистра в путях через os.path.normcase
	Удаление временного файла при ошибке

Итерация #12
	Удаление внешних зависимостей (Power Query) через загрузку без keep_vba/keep_links
	Принудительное сохранение как .xlsx
	Упрощенная логика без проверки VBA

Итерация #11
	Безопасная проверка VBA-кода через hasattr()
	Резервное определение формата по расширению исходника
	Совместимость с любыми версиями openpyxl

Итерация #10
	Динамическое определение формата сохранения (xlsx/xlsm)
	Удаление временного битого файла после сохранения
	Сохранение структуры книги при наличии макросов

Итерация #9
	Сначала копирование, затем фильтрация скопированного файла
	Безопасное удаление строк снизу вверх для сохранения индексов
	Удаление эмодзи, текстовые сообщения

Итерация #8
	Фильтрация данных в скопированном файле
	Удаление строк снизу вверх для сохранения индексов
	Сохранение форматирования и структуры книги

Итерация #7
	Добавлен выбор колонки для анализа
	Сбор уникальных значений (категорий) по всем листам
	Вывод отсортированных категорий с нумерацией

Итерация #6
	Анализ всех листов в книге
	Поиск пересечения заголовков между листами
	Вывод информации по каждому листу и общих колонок

Итерация #5
	Эвристический поиск заголовков в первых 10 строках
	Определение строки с максимальным количеством данных
	Вывод номера строки с заголовками

Итерация #4
	Добавлена обработка Excel через openpyxl
	Проверка расширения файла (.xlsx)
	Чтение заголовков из первой строки

Итерация #3
	Переход с CLI-аргументов на интерактивный ввод
	Исправление обработки путей с пробелами
	Добавлены подсказки для пользователя

Итерация #2
	Удален Flask, переход на CLI-скрипт
	Простой интерфейс через аргументы командной строки
	Упрощенная структура без веб-сервера

Итерация #1
	Добавлен эндпоинт /copy для копирования файлов
	Проверка существования исходного файла
	Автоматическое создание целевой директории

Итерация #0
	Инициализация проекта
	Отказ от слоев из-за простоты задачи

─── FILE: logging_config.py ───

import logging
import sys

def setup_logging():
    """Настраивает систему логирования для приложения."""
    logger = logging.getLogger('excel_splitter')
    logger.setLevel(logging.INFO)
    
    # Создаем обработчик для вывода в консоль
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    
    # Формат логов
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(formatter)
    
    # Добавляем обработчик, если он еще не добавлен
    if not logger.handlers:
        logger.addHandler(console_handler)
    
    return logger

# Создаем глобальный логгер
logger = setup_logging()

─── FILE: main.py ───

import sys
from cli.interface import main as cli_main

def run():
    """Точка входа в приложение. Может быть расширена для поддержки GUI в будущем"""
    cli_main()

if __name__ == "__main__":
    run()

─── FILE: cli\interface.py ───

from core.processing import process_file

def main():
    """Главный цикл программы: обработка файлов."""
    while True:
        success = process_file()
        # Спрашиваем, хочет ли пользователь продолжить
        if success:
            cont = input("\nDo you want to process another file? (y/n): ").strip().lower()
            if cont != 'y':
                print("Program terminated by user")
                break
        else:
            cont = input("\nDo you want to try again? (y/n): ").strip().lower()
            if cont != 'y':
                print("Program terminated by user")
                break

─── FILE: cli\__init__.py ───

# Импорты для пакета cli
from .interface import main

__all__ = ['main']

─── FILE: core\processing.py ───

import os
import logging
from excel_utils.analysis import get_all_sheets_headers, analyze_column
from excel_utils.filtering import get_all_combinations, select_categories_sequentially
from excel_utils.formatting import sanitize_filename, generate_short_filename
from excel_utils.workbook import create_filtered_file

logger = logging.getLogger('excel_splitter')

def process_file():
    """Обрабатывает один файл: выбор файла, директории, колонок, категорий, создание файлов."""
    logger.info("Starting file processing")
    print("\n=== Copy Excel File ===")
    print("To cancel the operation, press Ctrl+C at any time")
    try:
        # Шаг 0: Выбор исходного файла
        while True:
            source = input("\nEnter full path to source Excel file: ").strip('"')
            if source.lower() == "cancel":
                print("Operation cancelled by user")
                return False
            if os.path.exists(source) and os.path.isfile(source):
                # Проверка формата файла
                if not (source.lower().endswith('.xlsx') or source.lower().endswith('.xlsm')):
                    print("Error: File must have .xlsx or .xlsm extension")
                    continue
                break
            print(f"Error: Source file not found or is not a file: {source}")
        
        # Шаг 1: Выбор целевой директории
        while True:
            destination = input("Enter target directory path: ").strip('"')
            if destination.lower() == "cancel":
                print("Operation cancelled by user")
                return False
            if os.path.isdir(destination):
                break
            print(f"Error: Target directory does not exist: {destination}")
        
        # Анализ Excel: заголовки во всех листах
        sheet_headers = get_all_sheets_headers(source)
        valid_sheets = {sheet: data for sheet, data in sheet_headers.items() if data[0] is not None}
        if not valid_sheets:
            logger.error("No headers found in any sheet")
            print("Error: No headers found in any sheet")
            return False
        
        # Поиск пересечения заголовков
        all_headers = [set(headers) for headers, _ in valid_sheets.values()]
        common_headers = set.intersection(*all_headers) if all_headers else set()
        if not common_headers:
            logger.warning("No common headers found between sheets")
            print("\nWarning: No common headers found between sheets")
            return False
        
        # Шаг 2: Выбор колонок для фильтрации
        print("\nAvailable columns for filtering:")
        common_headers_list = list(common_headers)
        for i, col in enumerate(common_headers_list, 1):
            print(f"  {i}. {col}")
        print("  b. Назад")
        print("  c. Отмена")
        while True:
            columns_input = input("Enter columns for filtering (comma-separated numbers or names): ").strip()
            if columns_input.lower() in ["c", "cancel", "отмена"]:
                print("Operation cancelled by user")
                return False
            if columns_input.lower() in ["b", "back", "назад"]:
                return False  # Возврат к началу
            # Обработка номеров колонок
            hierarchy_columns = []
            invalid_inputs = []
            for item in columns_input.split(","):
                item = item.strip()
                if item.isdigit():
                    idx = int(item) - 1
                    if 0 <= idx < len(common_headers_list):
                        hierarchy_columns.append(common_headers_list[idx])
                    else:
                        invalid_inputs.append(item)
                else:
                    hierarchy_columns.append(item)
            # Проверка валидности
            invalid_columns = [col for col in hierarchy_columns if col not in common_headers]
            if invalid_columns or invalid_inputs:
                invalid_list = invalid_columns + invalid_inputs
                print(f"Error: Invalid columns: {', '.join(invalid_list)}")
                continue
            if not hierarchy_columns:
                print("Error: No valid columns selected")
                continue
            break
        
        # Шаг 3: Последовательный выбор категорий
        print("\nStarting sequential category selection...")
        all_combinations = select_categories_sequentially(source, valid_sheets, hierarchy_columns)
        if not all_combinations:
            print("No combinations selected")
            return False
        
        # Создание файлов
        os.makedirs(destination, exist_ok=True)
        base_name = os.path.splitext(os.path.basename(source))[0]
        created_files = []
        for filters in all_combinations:
            # Формируем имя файла с расширением .xlsx
            short_filename = generate_short_filename(
                os.path.join(destination, base_name),
                filters
            )
            target_file = os.path.join(destination, short_filename)
            
            # Создаем файл
            created_file = create_filtered_file(source, target_file, valid_sheets, filters)
            if created_file is not None:
                created_files.append(created_file)
        
        # Вывод результатов
        if created_files:
            print(f"\nCreated {len(created_files)} files:")
            for file in created_files:
                print(f"  - {file}")
        else:
            print("Warning: No files created (no data matched the filters)")
        return True
    except KeyboardInterrupt:
        logger.info("Operation cancelled by user (Ctrl+C)")
        print("\nOperation cancelled by user (Ctrl+C)")
        return False
    except Exception as e:
        logger.exception("Unexpected error during file processing")
        print(f"Error: {str(e)}")
        return False

─── FILE: core\__init__.py ───

# Импорты для пакета core
from .processing import process_file

__all__ = ['process_file']

─── FILE: excel_utils\analysis.py ───

from contextlib import contextmanager
import openpyxl
from .common import validate_row
import logging

logger = logging.getLogger('excel_splitter')

@contextmanager
def safe_workbook(file_path, read_only=False):
    """Контекстный менеджер для безопасной работы с файлами Excel."""
    wb = None
    try:
        wb = openpyxl.load_workbook(file_path, read_only=read_only)
        yield wb
    finally:
        if wb:
            try:
                wb.close()
            except Exception as e:
                logger.error(f"Error closing workbook: {str(e)}")

def get_all_sheets_headers(file_path, max_scan_rows=10):
    """Анализирует все ВИДИМЫЕ листы в Excel-файле, возвращает заголовки для каждого."""
    logger.info(f"Analyzing headers in {file_path}")
    try:
        with safe_workbook(file_path, read_only=True) as wb:
            sheet_results = {}
            for ws in wb.worksheets:
                # Игнорируем скрытые листы
                if ws.sheet_state != 'visible':
                    continue
                max_non_empty = 0
                header_row = None
                header_row_idx = 0
                for row_idx, row in enumerate(ws.iter_rows(min_row=1, max_row=max_scan_rows), start=1):
                    non_empty_count = sum(1 for cell in row if cell.value is not None)
                    if non_empty_count > max_non_empty:
                        max_non_empty = non_empty_count
                        header_row = row
                        header_row_idx = row_idx
                if max_non_empty > 0:
                    headers = [cell.value for cell in header_row if cell.value is not None]
                    sheet_results[ws.title] = (headers, header_row_idx)
                    logger.debug(f"Found headers in sheet {ws.title}: {headers}")
                else:
                    sheet_results[ws.title] = (None, None)
            return sheet_results
    except Exception as e:
        logger.error(f"Error analyzing Excel: {str(e)}")
        raise ValueError(f"Error analyzing Excel: {str(e)}")

def analyze_column(file_path, valid_sheets, selected_column, filters=None):
    """Собирает уникальные значения из указанной колонки с учетом фильтров."""
    if filters is None:
        filters = {}
    logger.info(f"Analyzing column {selected_column} with filters {filters}")
    try:
        with safe_workbook(file_path, read_only=True) as wb:
            categories = set()
            for sheet_name, (headers, row_idx) in valid_sheets.items():
                ws = wb[sheet_name]
                try:
                    col_index = headers.index(selected_column)
                except ValueError:
                    continue
                for row in ws.iter_rows(min_row=row_idx + 1, values_only=True):
                    if not validate_row(row, headers, row_idx, filters):
                        continue
                    cell_value = row[col_index] if col_index < len(row) else None
                    if cell_value is not None and str(cell_value).strip() != "":
                        categories.add(str(cell_value).strip())
            return sorted(categories)
    except Exception as e:
        logger.error(f"Error analyzing data: {str(e)}")
        raise ValueError(f"Error analyzing data: {str(e)}")

─── FILE: excel_utils\common.py ───

import logging

logger = logging.getLogger('excel_splitter')

def validate_row(row, headers, header_row_idx, filters):
    """Проверяет соответствие строки условиям фильтров."""
    logger.debug(f"Validating row: {row}, headers: {headers}, filters: {filters}")
    
    if not filters:
        logger.debug("No filters provided, row is valid")
        return True
        
    for col, value in filters.items():
        try:
            col_index = headers.index(col)
            cell_value = row[col_index] if col_index < len(row) else None
            str_value = str(cell_value).strip() if cell_value is not None else ""
            str_filter = str(value).strip()
            
            logger.debug(f"Checking column '{col}': cell value='{str_value}', filter='{str_filter}'")
            
            if str_value != str_filter:
                logger.debug(f"Row does not match filter for column '{col}'")
                return False
        except ValueError:
            logger.warning(f"Column '{col}' not found in headers")
            return False
    
    logger.debug("Row matches all filters")
    return True

─── FILE: excel_utils\filtering.py ───

from .analysis import analyze_column
import logging

logger = logging.getLogger('excel_splitter')

def get_all_combinations(source, valid_sheets, hierarchy_columns, filters=None, level=0):
    """Возвращает все возможные комбинации фильтров, включая частичные уровни."""
    if filters is None:
        filters = {}
    if level >= len(hierarchy_columns):
        return [filters.copy()]
    column = hierarchy_columns[level]
    logger.debug(f"Getting categories for column {column} with filters {filters}")
    categories = analyze_column(source, valid_sheets, column, filters)
    combinations = []
    # Добавляем комбинации для текущего уровня без добавления следующих уровней
    for category in categories:
        new_filters = filters.copy()
        new_filters[column] = category
        combinations.append(new_filters.copy())
    # Добавляем комбинации для следующих уровней
    for category in categories:
        new_filters = filters.copy()
        new_filters[column] = category
        combinations.extend(get_all_combinations(source, valid_sheets, hierarchy_columns, new_filters, level + 1))
    return combinations

def select_categories_sequentially(source, valid_sheets, hierarchy_columns):
    """Последовательно запрашивает выбор категорий у пользователя с отображением вариантов для каждой комбинации."""
    logger.info("Starting sequential category selection")
    all_combinations = []
    
    def generate_combinations(level, current_filters, include_all=False):
        if level >= len(hierarchy_columns):
            all_combinations.append(current_filters.copy())
            return
        column = hierarchy_columns[level]
        categories = analyze_column(source, valid_sheets, column, current_filters)
        if not categories:
            return
        # Проверяем, является ли текущий уровень последним
        is_last_level = (level == len(hierarchy_columns) - 1)
        # Если это не первый уровень и есть предыдущие фильтры
        if level > 0:
            logger.debug(f"Current filters: {current_filters}")
            print(f"\nCurrent filters:")
            for col, value in current_filters.items():
                print(f"  - {col}: {value}")
            # Если не последний уровень, спрашиваем, хочет ли пользователь выбрать все комбинации
            if not is_last_level:
                while True:
                    all_comb = input(f"Include all categories from '{hierarchy_columns[level]}' for current filters? (y/n): ").strip().lower()
                    if all_comb == 'y':
                        # Анализируем все возможные комбинации
                        for category in categories:
                            new_filters = current_filters.copy()
                            new_filters[column] = category
                            generate_combinations(level + 1, new_filters, True)
                        return
                    elif all_comb == 'n':
                        break
                    else:
                        print("Please enter 'y' or 'n'")
        # Выводим доступные категории с номерами
        print(f"\nAvailable categories for column '{column}':")
        for i, cat in enumerate(categories, 1):
            print(f"  {i}. {cat}")
        print("  b. Назад")
        print("  c. Отмена")
        # Запрашиваем выбор
        while True:
            selection = input(f"Enter categories for '{column}' (comma-separated numbers, 'all', 'b' for back, 'c' for cancel): ").strip()
            # Обработка специальных команд
            if selection.lower() in ["c", "cancel", "отмена"]:
                print("Operation cancelled by user")
                return
            if selection.lower() in ["b", "back", "назад"]:
                return
            # Обработка "all" - выбираем все категории
            if selection.lower() == "all":
                selected_categories = categories
                break
            # Обработка номеров
            user_categories = []
            invalid_inputs = []
            for item in selection.split(","):
                item = item.strip()
                if item.isdigit():
                    idx = int(item) - 1
                    if 0 <= idx < len(categories):
                        user_categories.append(categories[idx])
                    else:
                        invalid_inputs.append(item)
                else:
                    user_categories.append(item)
            # Проверка валидности
            invalid_categories = [cat for cat in user_categories if cat not in categories]
            if invalid_categories or invalid_inputs:
                invalid_list = invalid_categories + invalid_inputs
                print(f"Error: Invalid categories: {', '.join(invalid_list)}")
                continue
            selected_categories = user_categories
            break
        # Обрабатываем выбор
        for category in selected_categories:
            new_filters = current_filters.copy()
            new_filters[column] = category
            # Если пользователь выбрал "all" для предыдущего уровня
            if include_all and level > 0:
                generate_combinations(level + 1, new_filters, True)
            else:
                generate_combinations(level + 1, new_filters)
    
    # Начинаем генерацию комбинаций с первого уровня
    generate_combinations(0, {})
    # Добавляем частичные уровни фильтрации
    final_combinations = []
    for filters in all_combinations:
        # Добавляем фильтры всех подуровней
        for i in range(len(hierarchy_columns)):
            partial_filter = {}
            for j in range(i + 1):
                if hierarchy_columns[j] in filters:
                    partial_filter[hierarchy_columns[j]] = filters[hierarchy_columns[j]]
            final_combinations.append(partial_filter)
    # Удаляем дубликаты частичных фильтров
    unique_combinations = []
    seen = set()
    for filters in final_combinations:
        filter_tuple = tuple(sorted(filters.items()))
        if filter_tuple not in seen:
            seen.add(filter_tuple)
            unique_combinations.append(filters)
    return unique_combinations

─── FILE: excel_utils\formatting.py ───

import re
import os
import logging
from openpyxl.utils import get_column_letter

logger = logging.getLogger('excel_splitter')

def sanitize_filename(name):
    """Удаляет недопустимые символы из названия файла."""
    # Удаляем недопустимые символы
    name = re.sub(r'[\\/*?:"<>|]', '_', name)
    # Убираем лишние пробелы
    name = re.sub(r'\s+', ' ', name).strip()
    return name

def shorten_category_name(name):
    """
    Сокращает длинные названия категорий по правилам:
    - Для одного слова: первые 3 буквы
    - Для двух и более слов: первая буква каждого слова
    """
    if not name:
        return ""
    
    # Удаляем недопустимые символы
    name = sanitize_filename(name)
    
    # Если название короткое, оставляем как есть
    if len(name) <= 15:
        return name
    
    # Разбиваем на слова и берем первую букву каждого
    words = name.split()
    if len(words) > 1:
        # Берем первую букву каждого слова
        short_name = ''.join(word[0] for word in words if word)
    else:
        # Для одного слова берем первые 3 буквы
        short_name = name[:3]
    
    return short_name

def generate_short_filename(base_name, filters, max_length=150):
    """
    Генерирует короткое имя файла с учетом максимальной длины.
    Если длина превышает max_length, использует хэш для уникальности.
    """
    # Создаем список сокращенных названий категорий
    safe_parts = []
    for i, (col, value) in enumerate(filters.items()):
        if i == len(filters) - 1:  # Последняя категория - не сокращаем
            safe_parts.append(sanitize_filename(value))
        else:
            safe_parts.append(shorten_category_name(value))
    
    # Формируем суффикс
    suffix = "_".join(safe_parts) if safe_parts else "All"
    
    # Проверяем длину полного пути
    full_path = os.path.join(os.path.dirname(base_name), f"{os.path.basename(base_name)}_{suffix}.xlsx")
    
    # Если длина слишком большая, сокращаем
    if len(full_path) > max_length:
        logger.warning(f"Filename is too long ({len(full_path)} characters), shortening...")
        
        # Оставляем только последние N символов из суффикса
        max_suffix_length = max_length - len(base_name) - 5  # Учитываем '.xlsx' и '_'
        
        if max_suffix_length <= 0:
            # Если даже базовое имя слишком длинное, используем хэш
            import hashlib
            hash_suffix = hashlib.sha1(suffix.encode()).hexdigest()[:8]
            suffix = f"short_{hash_suffix}"
        else:
            # Сокращаем суффикс до допустимой длины
            suffix = suffix[:max_suffix_length]
    
    return f"{os.path.basename(base_name)}_{suffix}.xlsx"

─── FILE: excel_utils\workbook.py ───

import os
import re
import logging
import openpyxl
from copy import copy
from contextlib import contextmanager
from openpyxl.worksheet.table import Table, TableStyleInfo
from excel_utils.common import validate_row

logger = logging.getLogger('excel_splitter')

def get_column_letter(col_idx):
    """Конвертирует индекс столбца в букву (1 -> A, 26 -> Z, 27 -> AA и т.д.)"""
    letters = []
    while col_idx > 0:
        col_idx, remainder = divmod(col_idx - 1, 26)
        letters.append(chr(65 + remainder))
    return ''.join(reversed(letters))

def is_openpyxl_new_version():
    """Проверяет, является ли версия openpyxl новой (>= 3.0)"""
    try:
        from openpyxl import __version__
        major_version = int(__version__.split('.')[0])
        return major_version >= 3
    except (ImportError, ValueError):
        return False

@contextmanager
def safe_workbook(file_path, read_only=False):
    """Контекстный менеджер для безопасной работы с файлами Excel."""
    wb = None
    try:
        logger.debug(f"Opening workbook: {file_path}")
        wb = openpyxl.load_workbook(file_path, read_only=read_only)
        yield wb
    finally:
        if wb:
            try:
                wb.close()
                logger.debug(f"Workbook closed: {file_path}")
            except Exception as e:
                logger.error(f"Error closing workbook: {str(e)}")

def create_filtered_file(source, target, valid_sheets, filters):
    """Создаёт файл с фильтрацией по комбинации условий."""
    logger.info(f"Creating filtered file: {target} with filters {filters}")
    
    # Добавлена проверка на пустой фильтр
    if not filters:
        logger.info("Empty filters, copying all data")
    
    try:
        # Всегда сохраняем как .xlsx
        if target.lower().endswith('.xlsm'):
            logger.debug("Converting .xlsm to .xlsx format")
            target = target[:-5] + '.xlsx'
        
        with safe_workbook(source, read_only=False) as wb_source:
            wb_new = openpyxl.Workbook()
            wb_new.remove(wb_new.active)
            has_data = False  # Флаг наличия данных
            logger.debug(f"Processing {len(wb_source.sheetnames)} sheets")
            
            for sheet_name in wb_source.sheetnames:
                ws_source = wb_source[sheet_name]
                # Игнорируем скрытые листы
                if ws_source.sheet_state != 'visible':
                    logger.debug(f"Skipping hidden sheet: {sheet_name}")
                    continue
                
                ws_new = wb_new.create_sheet(title=sheet_name)
                logger.debug(f"Processing sheet: {sheet_name}")
                
                # Копирование ширины столбцов
                if hasattr(ws_source, 'column_dimensions'):
                    for col_letter, dim in ws_source.column_dimensions.items():
                        try:
                            ws_new.column_dimensions[col_letter].width = dim.width
                        except Exception as e:
                            logger.debug(f"Error copying column width for {col_letter}: {str(e)}")
                
                # Копирование высоты строк
                if hasattr(ws_source, 'row_dimensions'):
                    for row_idx, dim in ws_source.row_dimensions.items():
                        try:
                            ws_new.row_dimensions[row_idx].height = dim.height
                        except Exception as e:
                            logger.debug(f"Error copying row height for {row_idx}: {str(e)}")
                
                # Копирование объединенных ячеек
                if hasattr(ws_source, 'merged_cells'):
                    for merged_cell in ws_source.merged_cells.ranges:
                        try:
                            ws_new.merge_cells(str(merged_cell))
                        except Exception as e:
                            logger.debug(f"Error copying merged cells: {str(e)}")
                
                # Копирование условного форматирования
                if hasattr(ws_source, 'conditional_formatting'):
                    for cf in ws_source.conditional_formatting:
                        try:
                            # Проверяем тип объекта условного форматирования
                            if hasattr(cf, 'cfRule') and hasattr(cf, 'cfRules'):
                                # Новые версии openpyxl
                                for rule in cf.cfRules:
                                    ws_new.conditional_formatting.add(cf._get_range(), rule)
                            elif hasattr(cf, 'rules'):
                                # Средние версии
                                for rule in cf.rules:
                                    ws_new.conditional_formatting.add(cf._get_range(), rule)
                            else:
                                # Старые версии
                                ws_new.conditional_formatting.add(cf._range, cf)
                        except Exception as e:
                            logger.debug(f"Error copying conditional formatting: {str(e)}")
                
                if sheet_name in valid_sheets:
                    headers, header_row_idx = valid_sheets[sheet_name]
                    logger.debug(f"Headers for sheet {sheet_name}: {headers}")
                    logger.debug(f"Header row index: {header_row_idx}")
                    
                    # 1. Технические строки выше таблицы
                    for row_idx in range(1, header_row_idx):
                        for col_idx in range(1, ws_source.max_column + 1):
                            try:
                                cell = ws_source.cell(row=row_idx, column=col_idx)
                                if cell.value is not None or cell.has_style:
                                    new_cell = ws_new.cell(row=row_idx, column=col_idx, value=cell.value)
                                    if cell.has_style:
                                        # Копируем отдельные стили вместо общего
                                        try:
                                            new_cell.font = copy(cell.font)
                                            new_cell.border = copy(cell.border)
                                            new_cell.fill = copy(cell.fill)
                                            new_cell.alignment = copy(cell.alignment)
                                            new_cell.number_format = cell.number_format
                                        except Exception as e:
                                            logger.debug(f"Error copying individual style properties: {str(e)}")
                            except Exception as e:
                                logger.debug(f"Error copying cell at row {row_idx}, col {col_idx}: {str(e)}")
                    
                    # 2. Заголовки
                    for col_idx in range(1, ws_source.max_column + 1):
                        try:
                            cell = ws_source.cell(row=header_row_idx, column=col_idx)
                            if cell.value is not None or cell.has_style:
                                new_cell = ws_new.cell(row=header_row_idx, column=col_idx, value=cell.value)
                                if cell.has_style:
                                    # Копируем отдельные стили вместо общего
                                    try:
                                        new_cell.font = copy(cell.font)
                                        new_cell.border = copy(cell.border)
                                        new_cell.fill = copy(cell.fill)
                                        new_cell.alignment = copy(cell.alignment)
                                        new_cell.number_format = cell.number_format
                                    except Exception as e:
                                        logger.debug(f"Error copying individual style properties for header: {str(e)}")
                        except Exception as e:
                            logger.debug(f"Error copying header at col {col_idx}: {str(e)}")
                    
                    # 3. Фильтрация данных
                    new_row_idx = header_row_idx + 1
                    filtered_count = 0
                    for row_idx in range(header_row_idx + 1, ws_source.max_row + 1):
                        try:
                            row = ws_source[row_idx]
                            # Добавлена проверка на пустой фильтр
                            if not filters:
                                should_include = True
                            else:
                                should_include = validate_row([cell.value for cell in row], headers, header_row_idx, filters)
                            
                            if should_include:
                                filtered_count += 1
                                for col_idx in range(1, ws_source.max_column + 1):
                                    try:
                                        source_cell = ws_source.cell(row=row_idx, column=col_idx)
                                        if source_cell.value is not None or source_cell.has_style:
                                            new_cell = ws_new.cell(row=new_row_idx, column=col_idx, value=source_cell.value)
                                            if source_cell.has_style:
                                                # Копируем отдельные стили вместо общего
                                                try:
                                                    new_cell.font = copy(source_cell.font)
                                                    new_cell.border = copy(source_cell.border)
                                                    new_cell.fill = copy(source_cell.fill)
                                                    new_cell.alignment = copy(source_cell.alignment)
                                                    new_cell.number_format = source_cell.number_format
                                                except Exception as e:
                                                    logger.debug(f"Error copying individual style properties for data cell: {str(e)}")
                                    except Exception as e:
                                        logger.debug(f"Error copying data cell at row {row_idx}, col {col_idx}: {str(e)}")
                                new_row_idx += 1
                        except Exception as e:
                            logger.debug(f"Error processing row {row_idx}: {str(e)}")
                    
                    logger.debug(f"Filtered {filtered_count} rows out of {ws_source.max_row - header_row_idx} possible")
                    
                    # Проверка наличия данных
                    if new_row_idx > header_row_idx + 1:
                        has_data = True
                        # Форматируем данные как таблицу
                        last_col_letter = get_column_letter(ws_source.max_column)
                        table_range = f"A{header_row_idx}:{last_col_letter}{new_row_idx-1}"
                        
                        # Создаем таблицу
                        table = Table(displayName=f"Table{sheet_name}", ref=table_range)
                        
                        # Создаем стиль таблицы с только поддерживаемыми параметрами
                        try:
                            # Пытаемся использовать полный набор параметров
                            style = TableStyleInfo(
                                name="TableStyleMedium9",
                                showFirstColumn=False,
                                showLastColumn=False,
                                showRowHeaders=True,
                                showColumnHeaders=True
                            )
                        except TypeError:
                            # Используем базовые параметры, если некоторые не поддерживаются
                            try:
                                style = TableStyleInfo(
                                    name="TableStyleMedium9",
                                    showFirstColumn=False,
                                    showLastColumn=False,
                                    showColumnHeaders=True
                                )
                            except TypeError:
                                # Используем минимальный набор параметров
                                style = TableStyleInfo(
                                    name="TableStyleMedium9"
                                )
                        
                        table.tableStyleInfo = style
                        ws_new.add_table(table)
                    else:
                        # Удаляем лист без данных
                        wb_new.remove(ws_new)
                        logger.debug(f"Removed sheet {sheet_name} due to no matching data")
                        continue  # Переходим к следующему листу
                
                else:
                    logger.debug(f"Copying entire sheet {sheet_name} without filtering")
                    for row_idx in range(1, ws_source.max_row + 1):
                        for col_idx in range(1, ws_source.max_column + 1):
                            try:
                                cell = ws_source.cell(row=row_idx, column=col_idx)
                                if cell.value is not None or cell.has_style:
                                    new_cell = ws_new.cell(row=row_idx, column=col_idx, value=cell.value)
                                    if cell.has_style:
                                        # Копируем отдельные стили вместо общего
                                        try:
                                            new_cell.font = copy(cell.font)
                                            new_cell.border = copy(cell.border)
                                            new_cell.fill = copy(cell.fill)
                                            new_cell.alignment = copy(cell.alignment)
                                            new_cell.number_format = cell.number_format
                                        except Exception as e:
                                            logger.debug(f"Error copying individual style properties: {str(e)}")
                            except Exception as e:
                                logger.debug(f"Error copying cell at row {row_idx}, col {col_idx}: {str(e)}")
            
            if not has_data:
                logger.warning("No data matched the filters, file not created")
                return None
            
            # Удаляем целевой файл, если он существует
            if os.path.exists(target):
                logger.info(f"Removing existing target file: {target}")
                os.remove(target)
            
            # Сохраняем как .xlsx
            logger.info(f"Saving filtered file: {target}")
            wb_new.save(target)
            return target
    except Exception as e:
        logger.exception(f"Error during filtering: {str(e)}")
        raise ValueError(f"Error during filtering: {str(e)}")

─── FILE: excel_utils\__init__.py ───

# Импорты для пакета excel_utils
try:
    from .analysis import get_all_sheets_headers, analyze_column
    from .filtering import get_all_combinations, select_categories_sequentially
    from .formatting import sanitize_filename, generate_short_filename
    from .workbook import create_filtered_file
    from .common import validate_row
    
    __all__ = [
        'get_all_sheets_headers',
        'analyze_column',
        'get_all_combinations',
        'select_categories_sequentially',
        'sanitize_filename',
        'generate_short_filename',
        'create_filtered_file',
        'validate_row'
    ]
    
    # Проверка инициализации
    logger = logging.getLogger('excel_splitter')
    logger.debug("excel_utils package initialized successfully")
except Exception as e:
    import logging
    logger = logging.getLogger('excel_splitter')
    logger.error(f"Failed to initialize excel_utils package: {str(e)}")
    raise

─── FILE: gui\placeholder.py ───

# Заглушка для будущего GUI
# В следующих итерациях будет заменена на реальную реализацию

def launch_gui():
    """Запуск графического интерфейса (заглушка)"""
    print("GUI is not implemented yet. Running CLI version instead.")
    from cli.interface import main
    main()

─── FILE: gui\__init__.py ───

# Импорты для пакета gui
from .placeholder import launch_gui

__all__ = ['launch_gui']

─── FILE: tests\test_analysis.py ───

import unittest
from excel_utils.analysis import get_all_sheets_headers, analyze_column
from excel_utils.common import validate_row
import os
import tempfile

class TestExcelAnalysis(unittest.TestCase):
    def setUp(self):
        # Создаем тестовый Excel-файл
        self.temp_dir = tempfile.mkdtemp()
        self.test_file = os.path.join(self.temp_dir, "test.xlsx")
        
        from openpyxl import Workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Sheet1"
        ws.append(["Header1", "Header2", "Header3"])
        ws.append(["Data1", "ValueA", "100"])
        ws.append(["Data2", "ValueB", "200"])
        ws.append(["Data3", "ValueA", "300"])
        wb.save(self.test_file)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_get_all_sheets_headers(self):
        """Проверяет корректность определения заголовков в Excel-файле"""
        headers = get_all_sheets_headers(self.test_file)
        self.assertIn("Sheet1", headers)
        self.assertEqual(headers["Sheet1"][0], ["Header1", "Header2", "Header3"])
    
    def test_analyze_column(self):
        """Проверяет сбор уникальных значений из колонки"""
        headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in headers.items() if v[0] is not None}
        
        categories = analyze_column(self.test_file, valid_sheets, "Header2")
        self.assertEqual(categories, ["ValueA", "ValueB"])
    
    def test_validate_row(self):
        """Проверяет фильтрацию строк по условиям"""
        headers = ["Header1", "Header2", "Header3"]
        row = ["Data1", "ValueA", "100"]
        
        # Проверяем фильтр по одной колонке
        self.assertTrue(validate_row(row, headers, 1, {"Header2": "ValueA"}))
        self.assertFalse(validate_row(row, headers, 1, {"Header2": "ValueB"}))
        
        # Проверяем фильтр по нескольким колонкам
        self.assertTrue(validate_row(row, headers, 1, {"Header1": "Data1", "Header2": "ValueA"}))
        self.assertFalse(validate_row(row, headers, 1, {"Header1": "Data1", "Header2": "ValueB"}))

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_filename_shortening.py ───

import unittest
import os
import tempfile
from excel_utils.formatting import sanitize_filename, shorten_category_name, generate_short_filename

class TestFilenameShortening(unittest.TestCase):
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_sanitize_filename(self):
        """Проверяет удаление недопустимых символов из названия файла"""
        self.assertEqual(sanitize_filename("Test:File?Name*"), "Test_File_Name_")
        self.assertEqual(sanitize_filename("File with spaces"), "File with spaces")
        self.assertEqual(sanitize_filename("File<>|"), "File____")
    
    def test_shorten_category_name(self):
        """Проверяет сокращение длинных названий категорий"""
        # Тест с коротким именем
        self.assertEqual(shorten_category_name("IT"), "IT")
        
        # Тест с одним длинным словом
        self.assertEqual(shorten_category_name("Department"), "Dep")
        
        # Тест с несколькими словами
        self.assertEqual(shorten_category_name("Human Resources"), "HR")
        self.assertEqual(shorten_category_name("Apparatus Management"), "AM")
        self.assertEqual(shorten_category_name("Apparatus Management Development"), "AMD")
    
    def test_generate_short_filename(self):
        """Проверяет генерацию коротких имен файлов"""
        # Базовый случай
        base_path = os.path.join(self.temp_dir, "base_file")
        filters = {
            "Department": "Human Resources",
            "Team": "Development",
            "Project": "New Project"
        }
        filename = generate_short_filename(base_path, filters)
        self.assertEqual(filename, "base_file_HR_Dev_New Project.xlsx")
        
        # Сокращение для длинных имен
        base_path = os.path.join(self.temp_dir, "base_file")
        filters = {
            "Department": "Apparatus Management Development Department",
            "Team": "Development Team for New Projects"
        }
        filename = generate_short_filename(base_path, filters)
        self.assertEqual(filename, "base_file_AMDD_DTNPNP.xlsx")
        
        # Проверка ограничения длины
        base_path = os.path.join(self.temp_dir, "very_long_base_name" * 10)
        filters = {
            "Department": "Very Long Department Name " * 10,
            "Team": "Very Long Team Name " * 10
        }
        filename = generate_short_filename(base_path, filters)
        self.assertTrue(len(filename) <= 200)
        
        # Проверка хэширования при очень длинных именах
        base_path = os.path.join(self.temp_dir, "a" * 200)
        filters = {
            "Department": "b" * 200,
            "Team": "c" * 200
        }
        filename = generate_short_filename(base_path, filters)
        self.assertIn("short_", filename)
        self.assertEqual(len(filename), 200)

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_filtering.py ───

import unittest
import os
import tempfile
from excel_utils.common import validate_row

class TestFiltering(unittest.TestCase):
    def test_validate_row_empty_filters(self):
        """Проверяет, что строка проходит валидацию без фильтров"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertTrue(validate_row(row, headers, 1, {}))
    
    def test_validate_row_single_filter_match(self):
        """Проверяет, что строка соответствует одиночному фильтру"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertTrue(validate_row(row, headers, 1, {"Category": "A"}))
    
    def test_validate_row_single_filter_no_match(self):
        """Проверяет, что строка не соответствует одиночному фильтру"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertFalse(validate_row(row, headers, 1, {"Category": "B"}))
    
    def test_validate_row_multiple_filters_match(self):
        """Проверяет, что строка соответствует нескольким фильтрам"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertTrue(validate_row(row, headers, 1, {"Name": "Item1", "Category": "A"}))
    
    def test_validate_row_multiple_filters_no_match(self):
        """Проверяет, что строка не соответствует нескольким фильтрам"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertFalse(validate_row(row, headers, 1, {"Name": "Item2", "Category": "A"}))
    
    def test_validate_row_missing_column(self):
        """Проверяет обработку отсутствующего столбца в фильтре"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertFalse(validate_row(row, headers, 1, {"NonExistent": "Value"}))
    
    def test_validate_row_with_none_values(self):
        """Проверяет обработку None значений"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", None, "A"]
        self.assertTrue(validate_row(row, headers, 1, {"Value": ""}))
    
    def test_validate_row_case_sensitivity(self):
        """Проверяет обработку регистра"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertTrue(validate_row(row, headers, 1, {"category": "A"}))  # Строчные буквы в ключе

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_imports.py ───

import unittest
import sys
import os

# Добавляем корневую директорию проекта в путь для импорта
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

class TestModuleImports(unittest.TestCase):
    """Тест на проверку корректности импортов модулей"""
    
    def test_import_main(self):
        """Проверяет, что main.py импортируется без ошибок"""
        try:
            import main
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import main: {str(e)}")
    
    def test_import_cli(self):
        """Проверяет, что cli модуль импортируется без ошибок"""
        try:
            from cli import interface
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import cli: {str(e)}")
    
    def test_import_core(self):
        """Проверяет, что core модуль импортируется без ошибок"""
        try:
            from core import processing
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import core: {str(e)}")
    
    def test_import_excel_utils(self):
        """Проверяет, что excel_utils модуль импортируется без ошибок"""
        try:
            from excel_utils import (
                analysis, 
                filtering, 
                formatting, 
                workbook,
                get_all_sheets_headers,
                analyze_column,
                get_all_combinations,
                select_categories_sequentially,
                sanitize_filename,
                generate_short_filename,
                create_filtered_file
            )
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import excel_utils: {str(e)}")
    
    def test_import_specific_functions(self):
        """Проверяет доступность конкретных функций через пакетный импорт"""
        try:
            from excel_utils import (
                generate_short_filename,
                create_filtered_file
            )
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import specific functions: {str(e)}")

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_module_initialization.py ───

import unittest
import sys
import os
import logging

# Добавляем корневую директорию проекта в путь для импорта
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

class TestModuleInitialization(unittest.TestCase):
    """Тест на проверку корректной инициализации всех модулей"""
    
    def setUp(self):
        # Настройка логгера для тестов
        logging.basicConfig(level=logging.DEBUG)
        self.logger = logging.getLogger('test_initialization')
    
    def test_excel_utils_initialization(self):
        """Проверяет, что пакет excel_utils инициализируется без ошибок"""
        try:
            import excel_utils
            self.assertIsNotNone(excel_utils)
            self.logger.debug("excel_utils package imported successfully")
        except Exception as e:
            self.fail(f"Failed to import excel_utils package: {str(e)}")
    
    def test_all_modules_import(self):
        """Проверяет импорт всех модулей проекта"""
        modules = [
            'excel_utils.analysis',
            'excel_utils.filtering',
            'excel_utils.formatting',
            'excel_utils.workbook',
            'excel_utils.common',
            'core.processing',
            'cli.interface'
        ]
        
        for module in modules:
            try:
                __import__(module)
                self.logger.debug(f"Successfully imported {module}")
            except Exception as e:
                self.fail(f"Failed to import {module}: {str(e)}")
    
    def test_function_availability(self):
        """Проверяет доступность критических функций"""
        try:
            from excel_utils.formatting import generate_short_filename
            self.assertTrue(callable(generate_short_filename))
            
            from excel_utils.common import validate_row
            self.assertTrue(callable(validate_row))
            
            from excel_utils.workbook import create_filtered_file
            self.assertTrue(callable(create_filtered_file))
        except Exception as e:
            self.fail(f"Critical functions not available: {str(e)}")

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_special_formats.py ───

import unittest
import os
import tempfile
import openpyxl
from excel_utils.workbook import create_filtered_file
from excel_utils.analysis import get_all_sheets_headers
from excel_utils.common import validate_row

class TestSpecialFormats(unittest.TestCase):
    def setUp(self):
        # Создаем тестовый Excel-файл с особыми стилями и условным форматированием
        self.temp_dir = tempfile.mkdtemp()
        self.test_file = os.path.join(self.temp_dir, "test_special.xlsx")
        self.output_file = os.path.join(self.temp_dir, "output.xlsx")
        
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "TestSheet"
        
        # Добавляем заголовки
        ws.append(["ID", "Value", "Category"])
        
        # Добавляем данные
        for i in range(1, 11):
            ws.append([i, i*10, "A" if i % 2 == 0 else "B"])
        
        # Добавляем условное форматирование
        from openpyxl.formatting import Rule
        from openpyxl.formatting.rule import ColorScaleRule
        
        # Создаем правило условного форматирования
        rule = ColorScaleRule(
            start_type='min', start_color='FF0000',
            mid_type='percentile', mid_color='FFFF00',
            end_type='max', end_color='00FF00'
        )
        
        # Добавляем правило к диапазону
        ws.conditional_formatting.add('B2:B11', rule)
        
        # Добавляем специфический стиль (имитируем SAPBEXstdItem)
        from openpyxl.styles import NamedStyle
        sap_style = NamedStyle(name="SAPBEXstdItem")
        sap_style.font = openpyxl.styles.Font(bold=True)
        sap_style.fill = openpyxl.styles.PatternFill(start_color="00FF0000", end_color="00FF0000", fill_type="solid")
        
        # Применяем стиль к ячейке
        ws['A2'].style = sap_style
        
        wb.save(self.test_file)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_special_style_handling(self):
        """Проверяет обработку специфических стилей"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {"Category": "A"}
        
        # Пытаемся создать фильтрованный файл
        result = create_filtered_file(self.test_file, self.output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
    
    def test_conditional_formatting(self):
        """Проверяет копирование условного форматирования"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {"Category": "A"}
        
        # Пытаемся создать фильтрованный файл
        result = create_filtered_file(self.test_file, self.output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        
        # Проверяем, что условное форматирование присутствует в выходном файле
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем, что условное форматирование существует
        self.assertTrue(len(ws.conditional_formatting) > 0)
    
    def test_empty_filter(self):
        """Проверяет работу с пустым фильтром"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Пустой фильтр
        filters = {}
        
        # Пытаемся создать фильтрованный файл
        result = create_filtered_file(self.test_file, self.output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        
        # Проверяем, что все данные сохранены
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Должно быть 11 строк (заголовок + 10 данных)
        self.assertEqual(ws.max_row, 11)
    
    def test_no_matching_data(self):
        """Проверяет работу с фильтром, не находящим совпадений"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Фильтр, не должен находить совпадений
        filters = {"Category": "C"}
        
        # Пытаемся создать фильтрованный файл
        result = create_filtered_file(self.test_file, self.output_file, valid_sheets, filters)
        
        self.assertIsNone(result)
        self.assertFalse(os.path.exists(self.output_file))

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_table_formatting.py ───

import unittest
import os
import tempfile
import openpyxl
from excel_utils.workbook import create_filtered_file
from excel_utils.analysis import get_all_sheets_headers

class TestTableFormatting(unittest.TestCase):
    def setUp(self):
        # Создаем тестовый Excel-файл
        self.temp_dir = tempfile.mkdtemp()
        self.test_file = os.path.join(self.temp_dir, "test_table.xlsx")
        
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "TestSheet"
        
        # Добавляем заголовки
        ws.append(["ID", "Value", "Category"])
        
        # Добавляем данные
        for i in range(1, 11):
            ws.append([i, i*10, "A" if i % 2 == 0 else "B"])
        
        wb.save(self.test_file)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_table_creation(self):
        """Проверяет создание таблиц в результирующем файле"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {}
        
        output_file = os.path.join(self.temp_dir, "output.xlsx")
        result = create_filtered_file(self.test_file, output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
        
        # Проверяем, что таблица создана
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем, что есть таблица
        self.assertTrue(len(ws.tables) > 0)
        
        # Проверяем, что таблица имеет правильный диапазон
        table = list(ws.tables.values())[0]
        self.assertEqual(table.ref, "A1:C11")
    
    def test_table_with_filtering(self):
        """Проверяет создание таблицы при фильтрации данных"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем фильтр для категории A
        filters = {"Category": "A"}
        
        output_file = os.path.join(self.temp_dir, "output_filtered.xlsx")
        result = create_filtered_file(self.test_file, output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
        
        # Проверяем, что таблица создана
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем, что есть таблица
        self.assertTrue(len(ws.tables) > 0)
        
        # Проверяем, что таблица имеет правильный диапазон
        table = list(ws.tables.values())[0]
        self.assertEqual(table.ref, "A1:C6")  # 1 заголовок + 5 строк данных

if __name__ == '__main__':
    unittest.main()
