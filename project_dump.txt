=== PROJECT STRUCTURE ===

./
├── config.py
├── iteration_log.txt
├── logging_config.py
├── main.py
├── message.txt
├── requirements.txt
├── cli/
│   ├── interface.py
│   ├── __init__.py
├── core/
│   ├── processing.py
│   ├── __init__.py
├── excel_utils/
│   ├── analysis.py
│   ├── common.py
│   ├── filtering.py
│   ├── formatting.py
│   ├── workbook.py
│   ├── __init__.py
├── gui/
│   ├── main.py
│   ├── __init__.py
├── tests/
│   ├── test_analysis.py
│   ├── test_filename_shortening.py
│   ├── test_filtering.py
│   ├── test_imports.py
│   ├── test_module_initialization.py
│   ├── test_special_formats.py
│   ├── test_table_formatting.py
│   ├── __init__.py


=== FILE CONTENTS ===


─── FILE: config.py ───

# Конфигурация проекта
# Будет расширена в будущих итерациях

MAX_SCAN_ROWS = 10
DEFAULT_FILE_EXTENSION = '.xlsx'

─── FILE: iteration_log.txt ───

Итерация #65
	Ключевые изменения:
		Добавлена функция clean_table_name для очистки имен таблиц от недопустимых символов
		Улучшена логика последовательной фильтрации: добавлена опция выбора "все категории" на любом уровне
		Исправлено сокращение имен файлов: последняя категория больше не сокращается
		Добавлено сокращение имен папок по тем же правилам, что и имен файлов
		Добавлена проверка на длину имени папки для предотвращения проблем с ОС
	Решенные проблемы:
		Устранена ошибка "Table names cannot have spaces"
		Добавлена опция выбора "все категории" на любом уровне фильтрации
		Исправлено сокращение имен файлов в соответствии с требованиями
		Добавлено сокращение имен папок по тем же правилам, что и имен файлов
	

Итерация #64
	Ключевые изменения:
		Добавлен параметр is_folder_hierarchy в функцию generate_short_filename
		Упрощено создание стиля таблицы, оставлен только обязательный параметр name
		Улучшена обработка исключений при создании таблиц
		Добавлены более информативные сообщения об ошибках
	Решенные проблемы:
		Устранена ошибка "generate_short_filename() got an unexpected keyword argument 'is_folder_hierarchy'"
		Устранено предупреждение "TableStyleInfo.__init__() got an unexpected keyword argument 'showColumnHeaders'"
		Файлы теперь корректно создаются при использовании иерархии папок
	Проблемы:


Итерация #63
	Ключевые изменения:
		Полностью переработана логика сокращения названий категорий:
			- Добавлены списки предлогов и союзов на русском языке
			- Реализована обработка дефисов как разделителей
			- Союзы отображаются полностью в нижнем регистре
			- Добавлена обработка коротких результатов (менее 3 букв)
			- Сохранена логика сокращения всех категорий, кроме последней
		Улучшена обработка регистров в названиях
		Добавлены тесты для проверки новых правил сокращения
	Решенные проблемы:
		Устранена проблема с неправильным сокращением названий с предлогами и союзами
		Добавлена поддержка отображения союзов в нижнем регистре
		Реализована обработка коротких результатов с добавлением второй буквы
		Добавлена корректная обработка дефисов и тире
	Проблемы:
	

Итерация #62
	Ключевые изменения:
		Добавлено отображение количества и списка создаваемых файлов перед началом обработки
		Реализована опция выбора: создавать иерархию папок или сохранять все файлы в одну папку
		Добавлено подтверждение перед началом обработки
		Улучшена логика формирования путей к файлам
		Добавлена поддержка создания структуры папок в соответствии с иерархией фильтров
	Решенные проблемы:
		Пользователь теперь видит, какие файлы будут созданы, и может подтвердить обработку
		Добавлена возможность организации файлов в структуру папок по фильтрам
		Улучшена обработка путей к файлам для совместимости с новой функциональностью
	Проблемы:


Итерация #61
	Ключевые изменения:
		Добавлен простой графический интерфейс на Tkinter
		Сохранена вся существующая функциональность CLI
		Реализован выбор режима работы (CLI или GUI) при запуске
		Графический интерфейс интегрирован с существующей бизнес-логикой
	Решенные проблемы:
		Устранена необходимость в отдельном CLI для запуска приложения
		Добавлен графический интерфейс без потери текущей функциональности
		Графический интерфейс использует те же функции, что и CLI версия
	Проблемы:
		

Итерация #60
	Ключевые изменения:
		Упрощена логика генерации комбинаций фильтров:
		- Удален параметр include_all, который дублировал информацию
		- Добавлена явная проверка на последний уровень
		- Реализована специальная обработка для последнего уровня при выборе "all" на предыдущем уровне
		Улучшена обработка последнего уровня:
		- При выборе "all" на уровне перед последним автоматически добавляются все категории последнего уровня
		- Убрано избыточное запрос ввода для последнего уровня
		Уменьшено количество рекурсивных вызовов и упрощена логика обработки последнего уровня
	Решенные проблемы:
		Удален выбор "all" на последнем уровне фильтрации
		Устранена проблема с избыточным запросом ввода для последнего уровня
		Реализовано требование: "получить ВСЕ Должности, для КАЖДОГО из Подразделений, КАЖДОГО Директората"
	Проблемы:
		Требуется дальнейшее расширение тестового покрытия
		Нужно добавить проверку производительности при работе с большими наборами данных

Итерация #59
	Ключевые изменения:
		Переработана логика генерации комбинаций фильтров:
			- Добавлен явный выбор режима (all или точечный) для каждого уровня
			- При выборе "all" на уровне генерируются все возможные комбинации для последующих уровней
			- Убрано дублирование логики обработки частичных фильтров
		Улучшен пользовательский интерфейс:
			- Добавлено явное сообщение о текущем уровне и его режиме
			- Улучшена навигация между уровнями
			- Добавлена более детальная информация о текущих фильтрах
		Добавлена поддержка смешанных режимов (точечный выбор на одних уровнях, "all" на других)
	Решенные проблемы:
		Устранена проблема с неправильной генерацией комбинаций при выборе "all"
		Реализовано требование: "получить ВСЕ Должности, для КАЖДОГО из Подразделений, КАЖДОГО Директората"
		Добавлена явная опция выбора режима для каждого уровня фильтрации
	Проблемы:
		Требуется дальнейшее расширение тестового покрытия
		Нужно добавить проверку производительности при работе с большими наборами данных

Итерация #58
	Ключевые изменения:
		Устранена ошибка с пробелами в именах таблиц (Table names cannot have spaces)
		Реализовано новое правило сокращения названий категорий:
			- Одна категория: полное название
			- Несколько категорий: все, кроме последней, сокращаются по правилам
				* Две первые буквы первого слова (первая в верхнем, вторая в нижнем регистре)
				* Первая буква каждого последующего слова в верхнем регистре
		Восстановлено специфическое форматирование для "золотой работник"
		Добавлены тесты для проверки новых функциональных элементов
	Решенные проблемы:
		Устранена ошибка с именами таблиц, содержащими пробелы
		Реализовано новое правило сокращения названий категорий
		Восстановлено специфическое форматирование для "золотой работник"

Итерация #57 (не работоспособна)
	Ключевые изменения:
		Исправлены неподдерживаемые параметры стиля таблицы (showColumnHeaders -> showColumnHeaders)
		Уточнен диапазон таблицы для строгого соответствия данным
		Добавлена проверка на наличие данных в колонках для определения последней колонки
		Улучшена обработка диапазона таблицы для включения строк заголовков
	Решенные проблемы:
		Устранено предупреждение о неподдерживаемом параметре showColumnHeaders
		Диапазон таблицы теперь корректно включает заголовки и данные
		Таблица не захватывает лишние колонки
		Устранена проблема с определением границ таблицы
	Проблемы:
		Скорректировать сокращение названий категорий для именования файлов:
			Если одна категория в названии, то ее название полностью (как есть сейчас)
			Если несколько категорий в названии, то каждая, кроме последней, сокращается по принципу:
				Две первые буквы первого слова в категории (первая в верхнем, вторая в нижнем регистре) и первые буквы КАЖДОГО слова оригинального названия категории в верхнем регистре
					Например: Технический директорат_Департамент инженерно-технического обеспечения_Отдел по ремонту -> ТеД_ДеИТО_Отдел по ремонту
		Слетело жестко заданное на предыдущем шаге условное форматирование
		Возникает ошибка, файлы не создаются: Error: Error during filtering: Table names cannot have spaces

Итерация #56
	Ключевые изменения:
		Исправлен диапазон таблицы: таблица теперь создается только для данных, без технических строк выше
		Добавлено специфическое форматирование для колонок с "золотой работник" в соответствии с требованиями:
		- Значения "да" форматируются зеленым цветом
		- Значения "нет", "пробел", "запланирован" форматируются красным цветом
		- Другие значения остаются без заливки
		Добавлены тесты для проверки специфического форматирования и корректности диапазона таблицы
	Решенные проблемы:
		Устранена проблема с выходом границ таблицы за пределы данных
		Добавлено специфическое форматирование для колонок "золотой работник"
		Улучшена обработка технических строк выше таблицы
	Проблемы:
		В терминале предупреждения:
			2025-10-16 11:05:22,831 - excel_splitter - WARNING - TableStyleInfo parameters not fully supported: TableStyleInfo.__init__() got an unexpected keyword argument 'showColumnHeaders'. Did you mean 'showColumnStripes'?
			2025-10-16 11:05:22,832 - excel_splitter - WARNING - Using minimal table style
		Границы форматированных таблиц определяются некорректно:
			Первая строка - заголовки, сейчас первая строка это данные
			Последняя колонка, это последняя колонка фильтруемого диапазона орининальной таблицы, сейчас захыватывает лишние колонки

Итерация #55
	Ключевые изменения:
		Убран неподдерживаемый параметр showRowHeaders при создании стиля таблицы
		Добавлена проверка на поддержку параметров стиля таблицы
		Улучшена совместимость с разными версиями openpyxl
		Добавлены комментарии с объяснением поддерживаемых параметров
	Решенные проблемы:
		Устранена ошибка "TableStyleInfo.__init__() got an unexpected keyword argument 'showRowHeaders'"
		Таблицы теперь создаются без ошибок во всех поддерживаемых версиях openpyxl
		Стиль таблицы соответствует требованиям (бесцветная с черными границами)
	Проблемы:
		Границы форматированной таблицы выходят за рамки данных, захватывают лишние столбцы.
			Сверху у лишних стоблцов есть копированная техническая информация, она не должна учитываться при определении границ.
			Форматированная таблица создается только для фильтруемого диапазона данных
		Форматирование так и не переносится, тогда нужно задать его жестко (без учета регистра):
			Если название колонки содержит "золотой работник"
				Если ячейка содержит: 'пробел', 'нет', 'запланирован', то заливка rgb(255,80,80)
				Если 'да', то заливка rgb(150,200,80)
				Иначе без заливки
		Составить тесты для непокрытой функциональности
		

Итерация #54
	Ключевые изменения:
		Исправлен диапазон таблицы для строгого соответствия данным
		Использован стандартный стиль таблицы "TableStyleLight1" (бесцветная с черными границами)
		Переработана логика сокращения названий в соответствии с новыми требованиями
		Добавлена нормализация заголовков таблицы для устранения предупреждений
		Улучшена обработка условного форматирования для всех версий openpyxl
	Решенные проблемы:
		Устранена ошибка "We found a problem with some content in ..."
		Диапазон таблицы теперь строго соответствует данным
		Стиль таблицы соответствует требованиям (бесцветная с черными границами)
		Названия сокращаются по новым правилам
		Устранено предупреждение о нестроковых заголовках
		Улучшена обработка условного форматирования
	Проблемы:
		Требуется дальнейшее расширение тестового покрытия
		Нужно добавить проверку на обработку специфических типов данных

Итерация #53
	Ключевые изменения:
		Улучшена логика сокращения названий категорий для всех типов строк
		Добавлена замена всех недопустимых символов в sanitize_filename
		Сделано регистронезависимое сравнение в validate_row
		Улучшено копирование условного форматирования для всех версий openpyxl
	Решенные проблемы:
		Устранены ошибки с сокращением названий категорий
		Исправлена обработка недопустимых символов
		Добавлена поддержка разных регистров в фильтрах
		Улучшено копирование условного форматирования
	Проблемы:
		При открытии созданных файлов возникает предупреждение 'We found a problem with some content in ...'
			После попытки восстановления файл отрывается с сообщением 'Repaired Records: Table from /xl/tables/table1.xml part (Table)'
		Форматированная таблица выходит за пределы данных в итоговых файлах, а должна быть строго по ним
		Сокращение названий верхних уровней наименований файлов должно производиться по первым двум буквам первого слова, где первая в верхнем регистре, а вторая в нижем и первой буквы второго слова в верхнем регистре
		Во время сохранения файла в терминале предупреждение 'C:\Users\Pavel.Shelpov2\projects\excel_split\.venv\Lib\site-packages\openpyxl\worksheet\_writer.py:274: UserWarning: File may not be readable: column headings must be strings.warn("File may not be readable: column headings must be strings.")'
		Условное форматирование как не копировалось, так и не копируется
		Требуется дальнейшее расширение тестового покрытия

Итерация #51-52
	Ключевые изменения:
		Заменены импорты из пакета на прямые импорты из модулей для устранения циклических зависимостей
		Добавлена отладочная информация в __init__.py для диагностики проблем с инициализацией
		Добавлен тест проверки инициализации всех модулей и доступности критических функций
	Решенные проблемы (не проверяемо):
		Устранена ошибка ImportError: cannot import name 'generate_short_filename' from 'excel_utils'
		Обеспечена корректная инициализация всех модулей проекта
		Добавлена диагностика для выявления подобных проблем в будущем
	Проблемы:
		Требуется дальнейшее рефакторинг для полного устранения циклических зависимостей
		Тесты не запускаются из-за проблем импорта

Итерация #50
	Ключевые изменения:
		Исправлен импорт функции generate_short_filename через обновление __init__.py
		Добавлен тест на проверку корректности импортов всех модулей
		Улучшена документация экспортируемых функций
		Проверена доступность всех публичных функций через пакетный импорт
	Решенные проблемы (не проверяемо):
		Устранена ошибка ImportError: cannot import name 'generate_short_filename'
		Гарантирован доступ ко всем необходимым функциям через пакетный импорт
		Добавлены тесты для предотвращения подобных ошибок в будущем
	Проблемы:
		Требуется дальнейшее расширение тестового покрытия
		Нужно рассмотреть автоматизацию проверки импортов через статический анализ
		Провалены тесты:
			ImportError: Failed to import test module: cli
			ImportError: cannot import name 'generate_short_filename' from 'excel_utils'

Итерация #49
	Ключевые изменения:
		Исправлена ошибка с TableStyleInfo через использование только поддерживаемых параметров
		Реализовано сокращение длинных названий категорий по правилам:
			- Для одного слова: первые 3 буквы
			- Для двух и более слов: первая буква каждого слова
		Добавлена проверка длины пути к файлу и автоматическое сокращение при необходимости
		Добавлены тесты для проверки обработки длинных имен файлов
	Решенные проблемы (не может быть проверено):
		Устранена ошибка "TableStyleInfo.__init__() got an unexpected keyword argument 'showRowHeaders'"
		Устранена проблема с неправильным открытием файлов с длинными именами
		Добавлено сокращение длинных названий категорий в имена файлов
		Реализована проверка длины пути к файлу
	Проблемы:
		Требуется проверка совместимости с очень старыми версиями Excel
		Нужно добавить настройки стиля таблиц для пользовательской кастомизации
		Требуется добавить поддержку специфических таблиц (например, с итогами)
		ImportError: cannot import name 'generate_short_filename' from 'excel_utils'

Итерация #48
	Ключевые изменения:
		Реализована адаптивная обработка условного форматирования для разных версий openpyxl
		Убраны автофильтры и добавлено форматирование данных как таблиц
		Оптимизировано логирование для уменьшения количества предупреждений
		Добавлены тесты для проверки форматирования таблиц
	Решенные проблемы (не может быть проверено):
			Устранены ошибки копирования условного форматирования
			Убраны избыточные предупреждения о неизвестных стилях
			Добавлено форматирование данных как таблиц в результирующих файлах
			Убраны автофильтры из результирующих файлов
	Проблемы:
		Требуется проверка совместимости с очень старыми версиями Excel
		Нужно добавить настройки стиля таблиц для пользовательской кастомизации
		Требуется добавить поддержку специфических таблиц (например, с итогами)
		Созданные файлы с длинными названиями не открываются
		КРИТИЧЕСКАЯ ОШИБКА: TableStyleInfo.__init__() got an unexpected keyword argument 'showRowHeaders'
	Дополнения:
		Названия всех категорий в названии, кроме последнего (или первого, если категория одна), необходимо сокращать.
			Например: 'Аппарат управления' -> 'Аппарат управления', 'Аппарат управления_Управление развития_Отдел разработки' -> 'АпУ_УпР_Отдел разработки'

Итерация #47
	Ключевые изменения:
		Добавлена обработка неизвестных стилей (SAPBEXstdItem) с логированием вместо ошибок
		Переработана логика копирования условного форматирования для совместимости с разными версиями openpyxl
		Добавлены типизированные аннотации и улучшена документация кода
		Добавлены тесты для обработки специальных форматов и условного форматирования
	Решенные проблемы:
		Устранена ошибка "SAPBEXstdItem is not a known style"
		Устранены проблемы с анализом кода Pylance
		Добавлены дополнительные тесты для проверки обработки специальных форматов
	Проблемы:
		Множество предупреждений Unknown style detected and ignored for data cell
		Условное форматирование не переносится:
			Error copying conditional formatting: 'ConditionalFormatting' object has no attribute '_range'
			Failed to copy conditional formatting: 'ConditionalFormatting' object has no attribute 'type'
	Дополнения:
		Убрать добавление автофильров в результирующие файлы
		Форматировать диапазоны данных в итоговых файлах как таблицы

Итерация #46
	Ключевые изменения:
		Исправлены все импорты validate_row по проекту
		Добавлено детальное логирование для отслеживания работы фильтрации
		Улучшена обработка пустых фильтров и случаев без совпадений
		Добавлены тесты для проверки работы фильтрации
	Решенные проблемы:
		Устранена ошибка "name 'validate_row' is not defined"
		Исправлена неправильная обработка случаев без совпадений
		Добавлены проверки на пустые фильтры
		Программа отрабатывает полный цикл файлы создаются
	Возникшие критические проблемы:
		Нет
	Возникшие предупреждения:
		Терминал:
			Error copying data cell at row 1-2034, col 1-11: SAPBEXstdItem is not a known style
			Error copying conditional formatting: 'ConditionalFormatting' object has no attribute '_range'
			Failed to copy conditional formatting: 'ConditionalFormatting' object has no attribute '_range'
		processing.py 
			Доступ к "analyze_column" не осуществляется Pylance
			Доступ к "get_all_combinations" не осуществляется Pylance
	Требуемые дополнения (обновления):
		Требуется добавить больше тестов для обработки специальных типов данных
		Нужно настроить CI/CD для автоматического запуска тестов

Итерация #45
	Ключевые изменения:
		Полностью устранены циклические зависимости между модулями
		Вынесена функция validate_row в отдельный модуль common
		Добавлены тесты на проверку корректности импортов
		Добавлены логи для отслеживания процесса загрузки модулей
	Проблемы решены:
		Исправлена ошибка импорта, приложение запускается корректно
		Устранены циклические зависимости между analysis.py и filtering.py
		Добавлены тесты для проверки загрузки всех модулей
	Возникшие проблемы:
		if not validate_row([cell.value for cell in row], headers, header_row_idx, filters):
			"validate_row" не определено Pylancereport UndefinedVariable
			(function) validate_row: Any
		Error processing row 1-2059: name 'validate_row' is not defined
		No data matched the filters, file not created
		Warning: No files created (no data matched the filters)

Итерация #44
	Ключевые изменения:
		Исправлены имена инициализационных файлов (init.py -> __init__.py)
		Устранены циклические зависимости между модулями
		Добавлена система логирования с базовой конфигурацией
		Добавлена структура для unit-тестов с первым тестом
	Проблемы решены:
		Исправлена ошибка импорта, приложение запускается корректно
			НЕ РЕШЕНО:
				Traceback (most recent call last):
					File "c:\Users\Pavel.Shelpov2\projects\excel_split\main.py", line 2, in <module>
						from cli.interface import main as cli_main
					File "c:\Users\Pavel.Shelpov2\projects\excel_split\cli\__init__.py", line 2, in <module>
						from .interface import main
					File "c:\Users\Pavel.Shelpov2\projects\excel_split\cli\interface.py", line 1, in <module>
						from core.processing import process_file
					File "c:\Users\Pavel.Shelpov2\projects\excel_split\core\__init__.py", line 2, in <module>
						from .processing import process_file
					File "c:\Users\Pavel.Shelpov2\projects\excel_split\core\processing.py", line 3, in <module>
						from excel_utils import (
						...<6 lines>...
						)
					File "c:\Users\Pavel.Shelpov2\projects\excel_split\excel_utils\__init__.py", line 3, in <module>
						from .filtering import validate_row, get_all_combinations, select_categories_sequentially
					ImportError: cannot import name 'validate_row' from 'excel_utils.filtering' (c:\Users\Pavel.Shelpov2\projects\excel_split\excel_utils\filtering.py)
		Добавлены логи для отслеживания операций
		Добавлена базовая структура для тестирования
	Проблемы:
		Требуется добавить больше unit-тестов для ключевых функций
		Нужно настроить CI/CD для автоматического запуска тестов

Итерация #43
    Ключевые изменения:
        Внедрена модульная структура проекта: разделение на логические модули (excel_utils, cli, core, gui)
        Создана основа для расширения: добавлены заготовки для будущего GUI
        Улучшена поддерживаемость: добавлены типизированные аннотации, оптимизированы импорты
    Проблемы:
        Требуется добавление системы логирования для отслеживания операций
        Нужно внедрить unit-тесты для критически важных функций
		Работоспособность нарушена:
			Traceback (most recent call last):
				File "c:\Users\Pavel.Shelpov2\projects\excel_split\main.py", line 2, in <module>
					from cli.interface import main as cli_main
				File "c:\Users\Pavel.Shelpov2\projects\excel_split\cli\interface.py", line 1, in <module>
					from core.processing import process_file
				File "c:\Users\Pavel.Shelpov2\projects\excel_split\core\processing.py", line 3, in <module>
					from excel_utils import (
					...<7 lines>...
					)
			ImportError: cannot import name 'get_all_sheets_headers' from 'excel_utils' (unknown location)

Итерация #42
	Ключевые изменения:
		Убрана поддержка .xlsm, все файлы сохраняются как .xlsx.
		Исправлено копирование условного форматирования для всех типов правил.
		Упрощена логика сохранения файлов.
	Проблемы:
		Нет возможности вернуться и выбрать другой файл после его выбора, только через ctrl+c
		Многоуровневая фильтрация не дает возможности выбрать все уровни разом, а только точечно

Итерация #41
	Ключевые изменения:
		Добавлена опция выбора всех комбинаций с подтверждением.
		Исправлено копирование условного форматирования для .xlsm файлов.
		Ограничена область автофильтра только строкой заголовков.
	Проблемы:
		Условное форматирование не переносится

Итерация #40
	Ключевые изменения:
		Полностью переработана логика выбора категорий с использованием рекурсии для правильного отображения вариантов.
		Исправлено сохранение .xlsm файлов с макросами.
		Добавлена обработка частичных уровней фильтрации
	Проблемы:
		В результаты xlsm не переносится условное форматирование
		Кнопки фильтров растягиваются дальше заголовков по строке

Итерация #39
	Изменено:
		Полностью переработана логика генерации комбинаций фильтров для множественного выбора.
		Исправлено сохранение .xlsm файлов с макросами.
		Добавлена обработка частичных уровней фильтрации.
	Проблемы:
		Проблема с комбинациями категорий не исправлена
		Error: Error during filtering: Workbook.__init__() got an unexpected keyword argument 'keep_vba'

Итерация #38
	Изменено:
		Убран недопустимый параметр keep_vba при создании нового файла.
		Переработана логика выбора категорий для отображения вариантов для каждой комбинации.
		Исправлено зацикливание при выборе последней колонки.
	Выявленные проблемы:
		Проблема с комбинациями категорий не исправлена:
			Выбираются две колонки, в первой выбираются две категории, для второй выбираются all, ожидается, что для каждой из первых двух категорий будут подобраны все комбинации из второй, чего не проиходит

Итерация #37
	Изменено:
		Удален недопустимый параметр keep_vba при создании нового файла.
		Добавлена корректная обработка макросов для .xlsm файлов через параметр при загрузке.
		Улучшена логика сохранения макросов при работе с .xlsm файлами.
	Выявленные проблемы:
		Не решено: Error: Error during filtering: Workbook.__init__() got an unexpected keyword argument 'keep_vba' после выбора последней категории в любых файлах
		Выбор категорий уровнями ниже осуществляется некорректно, ищет только пересечения с уровнями выше, а нужно учитывать все комбинации.

Итерация #36
	Изменено:
		Добавлена проверка видимости листов при анализе.
		Исправлена ошибка с keep_vba для .xlsx файлов.
		Улучшена обработка скрытых листов на всех этапах.
	Выявленные проблемы:
		Error: Error during filtering: Workbook.__init__() got an unexpected keyword argument 'keep_vba' после выбора последней категории в любых файлах

Итерация #35
	Добавлена проверка наличия данных на листе перед добавлением в результирующий файл.
	Добавлен автофильтр в строку заголовков результирующих файлов.
	Добавлена поддержка .xlsm файлов с сохранением макросов.

Итерация #34
	Исправлена обработка ключевого слова "all" в выборе категорий
	Улучшена логика генерации комбинаций для множественного выбора
	Создаются файлы для всех выбранных комбинаций, включая частичные уровни

Итерация #33
	Создана отдельная функция process_file() для обработки одного файла
	Упрощен главный цикл программы
	Исправлено зацикливание при выборе последней колонки
	Добавлена обработка ошибок на каждом этапе

Итерация #32
	Удален запрос подтверждения после успешного выполнения
	Программа автоматически возвращается к выбору файла после успешной обработки
	Улучшена обработка ошибок для бесшовного перехода к следующей итерации

Итерация #31
	Добавлено отображение колонок в нумерованном списке
	Улучшена обработка ошибок ввода с возвратом к предыдущему шагу
	Добавлена возможность отмены шага и исправления предыдущего ввода
	Исправлена ошибка UnboundLocalError при прерывании через Ctrl+C
	Улучшена логика создания файлов для всех уровней комбинаций

Итерация #30
	Разделение на два режима: анализ данных в read-only, создание файлов в полном режиме
	Добавлены проверки на наличие атрибутов column_dimensions и row_dimensions
	Улучшена обработка исключений для предотвращения повреждения оригинального файла

Итерация #29
	Восстановлен режим read_only=False с безопасным управлением ресурсами
	Добавлены контекстные менеджеры для гарантированного закрытия файлов
	Улучшена обработка исключений для предотвращения повреждения оригинального файла

Итерация #28
	Последовательный выбор категорий: пользователь последовательно выбирает категории для каждой колонки
	Динамический анализ доступных категорий: на каждом этапе отображаются только доступные варианты
	Оптимизация производительности: кэширование промежуточных результатов

Итерация #27
	Восстановлена оригинальная фильтрация для одного уровня
	Иерархическая обработка выделена в отдельную функцию
	Добавлена возможность отмены операции через Ctrl+C

Итерация #26
	Переключение на read_only=True для загрузки исходного файла
	Добавлена явная проверка на существование целевого файла перед сохранением
	Улучшена обработка исключений для гарантированного закрытия файлов

Итерация #25
	Восстановлено полное копирование стилей (цвета, шрифты, границы)
	Сохранение ширины столбцов и высоты строк
	Исправлено копирование объединенных ячеек

Итерация #24
	Последовательная обработка уровней сверху вниз
	Итеративный подход вместо рекурсии
	Проверка данных перед созданием файлов

Итерация #23
	Упрощенная логика фильтрации при выборе одной колонки
	Добавлена опция выбора нескольких категорий
	Генерация имен файлов с префиксами уровней

Итерация #22
	Восстановлено полное копирование стилей (цвета, шрифты, границы)
	Сохранение ширины столбцов и высоты строк
	Исправлено копирование объединенных ячеек

Итерация #21
	Устранена проблема с техническими строками ниже таблицы
	Оптимизирована производительность за счет упрощения копирования стилей
	Восстановлена базовая фильтрация для одной колонки

Итерация #20
	Восстановлена оригинальная фильтрация для одного уровня
	Иерархическая обработка выделена в отдельную функцию
	Добавлена возможность отмены операции через Ctrl+C

Итерация #19
	Последовательная обработка уровней сверху вниз
	Итеративный подход вместо рекурсии
	Проверка данных перед созданием файлов

Итерация #18
	Поддержка выбора нескольких колонок через запятую
	Создание файлов для каждого уровня иерархии
	Формирование имен файлов с префиксами всех предыдущих уровней

Итерация #17
	Добавлена поддержка множественного выбора категорий через запятую и ключевое слово "all"
	Генерация имен файлов с суффиксом категории и защитой от недопустимых символов
	Циклическая обработка каждой категории с созданием отдельных файлов

Итерация #16
	Устранены предупреждения через импорт copy и замену .copy()
	Сохранение числовых форматов (даты, валюта) через number_format
	Полная совместимость с openpyxl без предупреждений

Итерация #15
	Полное сохранение форматирования: стили, объединения, ширина/высота
	Сохранение технических строк выше и ниже таблицы
	Создание нового файла "с нуля" без внешних зависимостей

Итерация #14
	Создание чистого файла без внешних зависимостей через Workbook()
	Копирование только значений ячеек (без форматирования)
	Гарантированная совместимость с Excel

Итерация #13
	Условное удаление временного файла только при изменении расширения
	Обработка регистра в путях через os.path.normcase
	Удаление временного файла при ошибке

Итерация #12
	Удаление внешних зависимостей (Power Query) через загрузку без keep_vba/keep_links
	Принудительное сохранение как .xlsx
	Упрощенная логика без проверки VBA

Итерация #11
	Безопасная проверка VBA-кода через hasattr()
	Резервное определение формата по расширению исходника
	Совместимость с любыми версиями openpyxl

Итерация #10
	Динамическое определение формата сохранения (xlsx/xlsm)
	Удаление временного битого файла после сохранения
	Сохранение структуры книги при наличии макросов

Итерация #9
	Сначала копирование, затем фильтрация скопированного файла
	Безопасное удаление строк снизу вверх для сохранения индексов
	Удаление эмодзи, текстовые сообщения

Итерация #8
	Фильтрация данных в скопированном файле
	Удаление строк снизу вверх для сохранения индексов
	Сохранение форматирования и структуры книги

Итерация #7
	Добавлен выбор колонки для анализа
	Сбор уникальных значений (категорий) по всем листам
	Вывод отсортированных категорий с нумерацией

Итерация #6
	Анализ всех листов в книге
	Поиск пересечения заголовков между листами
	Вывод информации по каждому листу и общих колонок

Итерация #5
	Эвристический поиск заголовков в первых 10 строках
	Определение строки с максимальным количеством данных
	Вывод номера строки с заголовками

Итерация #4
	Добавлена обработка Excel через openpyxl
	Проверка расширения файла (.xlsx)
	Чтение заголовков из первой строки

Итерация #3
	Переход с CLI-аргументов на интерактивный ввод
	Исправление обработки путей с пробелами
	Добавлены подсказки для пользователя

Итерация #2
	Удален Flask, переход на CLI-скрипт
	Простой интерфейс через аргументы командной строки
	Упрощенная структура без веб-сервера

Итерация #1
	Добавлен эндпоинт /copy для копирования файлов
	Проверка существования исходного файла
	Автоматическое создание целевой директории

Итерация #0
	Инициализация проекта
	Отказ от слоев из-за простоты задачи

─── FILE: logging_config.py ───

import logging
import sys

def setup_logging():
    """Настраивает систему логирования для приложения."""
    logger = logging.getLogger('excel_splitter')
    logger.setLevel(logging.INFO)
    
    # Проверяем, не добавлены ли уже обработчики
    if not logger.handlers:
        # Создаем обработчик для вывода в консоль
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(logging.INFO)
        
        # Формат логов
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        console_handler.setFormatter(formatter)
        
        # Добавляем обработчик
        logger.addHandler(console_handler)
    
    return logger

# Создаем глобальный логгер
logger = setup_logging()

─── FILE: main.py ───

import sys
import os

def run_cli():
    """Запускает CLI версию приложения"""
    from cli.interface import main as cli_main
    cli_main()

def run_gui():
    """Запускает GUI версию приложения"""
    from gui.main import launch_gui
    launch_gui()

def main():
    """Точка входа в приложение с выбором режима работы"""
    if len(sys.argv) > 1 and sys.argv[1] == "cli":
        run_cli()
    elif len(sys.argv) > 1 and sys.argv[1] == "gui":
        run_gui()
    else:
        print("Excel Splitter")
        print("1. Command Line Interface (CLI)")
        print("2. Graphical User Interface (GUI)")
        print("3. Exit")
        
        choice = input("Enter your choice (1/2/3): ").strip()
        
        if choice == "1":
            run_cli()
        elif choice == "2":
            run_gui()
        elif choice == "3":
            print("Exiting...")
        else:
            print("Invalid choice. Please enter 1, 2, or 3.")
            main()

if __name__ == "__main__":
    main()

─── FILE: message.txt ───



─── FILE: requirements.txt ───

openpyxl>=3.0.0

─── FILE: cli\interface.py ───

from core.processing import process_file

def main():
    """Главный цикл программы: обработка файлов."""
    while True:
        success = process_file()
        # Спрашиваем, хочет ли пользователь продолжить
        if success:
            cont = input("\nDo you want to process another file? (y/n): ").strip().lower()
            if cont != 'y':
                print("Program terminated by user")
                break
        else:
            cont = input("\nDo you want to try again? (y/n): ").strip().lower()
            if cont != 'y':
                print("Program terminated by user")
                break

─── FILE: cli\__init__.py ───

# Импорты для пакета cli
from .interface import main

__all__ = ['main']

─── FILE: core\processing.py ───

import os
import logging
from excel_utils.analysis import get_all_sheets_headers, analyze_column
from excel_utils.filtering import select_categories_sequentially
from excel_utils.formatting import sanitize_filename, generate_short_filename
from excel_utils.workbook import create_filtered_file
logger = logging.getLogger('excel_splitter')

def process_file():
    """Обрабатывает один файл: выбор файла, директории, колонок, категорий, создание файлов."""
    logger.info("Starting file processing")
    print("\n=== Copy Excel File ===")
    print("To cancel the operation, press Ctrl+C at any time")
    try:
        # Шаг 0: Выбор исходного файла
        while True:
            source = input("\nEnter full path to source Excel file: ").strip('"')
            if source.lower() == "cancel":
                print("Operation cancelled by user")
                return False
            if os.path.exists(source) and os.path.isfile(source):
                # Проверка формата файла
                if not (source.lower().endswith('.xlsx') or source.lower().endswith('.xlsm')):
                    print("Error: File must have .xlsx or .xlsm extension")
                    continue
                break
            print(f"Error: Source file not found or is not a file: {source}")
        
        # Шаг 1: Выбор целевой директории
        while True:
            destination = input("Enter target directory path: ").strip('"')
            if destination.lower() == "cancel":
                print("Operation cancelled by user")
                return False
            if os.path.isdir(destination):
                break
            print(f"Error: Target directory does not exist: {destination}")
        
        # Анализ Excel: заголовки во всех листах
        sheet_headers = get_all_sheets_headers(source)
        valid_sheets = {sheet: data for sheet, data in sheet_headers.items() if data[0] is not None}
        if not valid_sheets:
            logger.error("No headers found in any sheet")
            print("Error: No headers found in any sheet")
            return False
        
        # Поиск пересечения заголовков
        all_headers = [set(headers) for headers, _ in valid_sheets.values()]
        common_headers = set.intersection(*all_headers) if all_headers else set()
        if not common_headers:
            logger.warning("No common headers found between sheets")
            print("\nWarning: No common headers found between sheets")
            return False
        
        # Шаг 2: Выбор колонок для фильтрации
        print("\nAvailable columns for filtering:")
        common_headers_list = list(common_headers)
        for i, col in enumerate(common_headers_list, 1):
            print(f"  {i}. {col}")
        print("  b. Назад")
        print("  c. Отмена")
        while True:
            columns_input = input("Enter columns for filtering (comma-separated numbers or names): ").strip()
            if columns_input.lower() in ["c", "cancel", "отмена"]:
                print("Operation cancelled by user")
                return False
            if columns_input.lower() in ["b", "back", "назад"]:
                return False  # Возврат к началу
            # Обработка номеров колонок
            hierarchy_columns = []
            invalid_inputs = []
            for item in columns_input.split(","):
                item = item.strip()
                if item.isdigit():
                    idx = int(item) - 1
                    if 0 <= idx < len(common_headers_list):
                        hierarchy_columns.append(common_headers_list[idx])
                    else:
                        invalid_inputs.append(item)
                else:
                    hierarchy_columns.append(item)
            # Проверка валидности
            invalid_columns = [col for col in hierarchy_columns if col not in common_headers]
            if invalid_columns or invalid_inputs:
                invalid_list = invalid_columns + invalid_inputs
                print(f"Error: Invalid columns: {', '.join(invalid_list)}")
                continue
            if not hierarchy_columns:
                print("Error: No valid columns selected")
                continue
            break
        
        # Шаг 3: Последовательный выбор категорий
        print("\nStarting sequential category selection...")
        all_combinations = select_categories_sequentially(source, valid_sheets, hierarchy_columns)
        if not all_combinations:
            print("No combinations selected")
            return False
        
        # Шаг 4: Опция выбора: создать иерархию папок или сохранить все файлы в одну папку
        create_hierarchy = input("\nDo you want to create folder hierarchy based on filter levels? (y/n): ").strip().lower() == 'y'
        
        # Шаг 5: Формирование путей к файлам
        base_name = os.path.splitext(os.path.basename(source))[0]
        file_list = []
        
        # Формируем пути для всех комбинаций
        for filters in all_combinations:
            if create_hierarchy:
                # Создаем путь с иерархией папок
                current_path = destination
                for col, value in filters.items():
                    # Используем полное имя категории для папки
                    folder_name = sanitize_filename(value)
                    current_path = os.path.join(current_path, folder_name)
                # Генерируем имя файла без включения пути
                short_filename = generate_short_filename(
                    os.path.join(current_path, base_name),
                    filters,
                    is_folder_hierarchy=True
                )
                full_path = os.path.join(current_path, short_filename)
                file_list.append((filters, full_path))
            else:
                # Сохраняем все файлы в одну папку
                short_filename = generate_short_filename(
                    os.path.join(destination, base_name),
                    filters,
                    is_folder_hierarchy=False
                )
                full_path = os.path.join(destination, short_filename)
                file_list.append((filters, full_path))
        
        # Шаг 6: Отображаем информацию и запрашиваем подтверждение
        print(f"\nWill create {len(file_list)} files:")
        for i, (_, file_path) in enumerate(file_list, 1):
            print(f"  {i}. {file_path}")
        
        if input("\nProceed with processing? (y/n): ").strip().lower() != 'y':
            print("Processing cancelled by user")
            return False
        
        # Создаем все необходимые папки
        for _, full_path in file_list:
            os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        # Шаг 7: Создание файлов
        created_files = []
        for filters, full_path in file_list:
            # Создаем файл
            created_file = create_filtered_file(source, full_path, valid_sheets, filters)
            if created_file is not None:
                created_files.append(created_file)
        
        # Вывод результатов
        if created_files:
            print(f"\nCreated {len(created_files)} files:")
            for file in created_files:
                print(f"  - {file}")
        else:
            print("Warning: No files created (no data matched the filters)")
        return True
    except KeyboardInterrupt:
        logger.info("Operation cancelled by user (Ctrl+C)")
        print("\nOperation cancelled by user (Ctrl+C)")
        return False
    except Exception as e:
        logger.exception("Unexpected error during file processing")
        print(f"Error: {str(e)}")
        return False

─── FILE: core\__init__.py ───

# Импорты для пакета core
from .processing import process_file

__all__ = ['process_file']

─── FILE: excel_utils\analysis.py ───

from contextlib import contextmanager
import openpyxl
from .common import validate_row
import logging

logger = logging.getLogger('excel_splitter')

@contextmanager
def safe_workbook(file_path, read_only=False):
    """Контекстный менеджер для безопасной работы с файлами Excel."""
    wb = None
    try:
        wb = openpyxl.load_workbook(file_path, read_only=read_only)
        yield wb
    finally:
        if wb:
            try:
                wb.close()
            except Exception as e:
                logger.error(f"Error closing workbook: {str(e)}")

def get_all_sheets_headers(file_path, max_scan_rows=10):
    """Анализирует все ВИДИМЫЕ листы в Excel-файле, возвращает заголовки для каждого."""
    logger.info(f"Analyzing headers in {file_path}")
    try:
        with safe_workbook(file_path, read_only=True) as wb:
            sheet_results = {}
            for ws in wb.worksheets:
                # Игнорируем скрытые листы
                if ws.sheet_state != 'visible':
                    continue
                max_non_empty = 0
                header_row = None
                header_row_idx = 0
                for row_idx, row in enumerate(ws.iter_rows(min_row=1, max_row=max_scan_rows), start=1):
                    non_empty_count = sum(1 for cell in row if cell.value is not None)
                    if non_empty_count > max_non_empty:
                        max_non_empty = non_empty_count
                        header_row = row
                        header_row_idx = row_idx
                if max_non_empty > 0:
                    headers = [cell.value for cell in header_row if cell.value is not None]
                    sheet_results[ws.title] = (headers, header_row_idx)
                    logger.debug(f"Found headers in sheet {ws.title}: {headers}")
                else:
                    sheet_results[ws.title] = (None, None)
            return sheet_results
    except Exception as e:
        logger.error(f"Error analyzing Excel: {str(e)}")
        raise ValueError(f"Error analyzing Excel: {str(e)}")

def analyze_column(file_path, valid_sheets, selected_column, filters=None):
    """Собирает уникальные значения из указанной колонки с учетом фильтров."""
    if filters is None:
        filters = {}
    logger.info(f"Analyzing column {selected_column} with filters {filters}")
    try:
        with safe_workbook(file_path, read_only=True) as wb:
            categories = set()
            for sheet_name, (headers, row_idx) in valid_sheets.items():
                ws = wb[sheet_name]
                try:
                    col_index = headers.index(selected_column)
                except ValueError:
                    continue
                for row in ws.iter_rows(min_row=row_idx + 1, values_only=True):
                    if not validate_row(row, headers, row_idx, filters):
                        continue
                    cell_value = row[col_index] if col_index < len(row) else None
                    if cell_value is not None and str(cell_value).strip() != "":
                        categories.add(str(cell_value).strip())
            return sorted(categories)
    except Exception as e:
        logger.error(f"Error analyzing data: {str(e)}")
        raise ValueError(f"Error analyzing data: {str(e)}")

─── FILE: excel_utils\common.py ───

import logging
logger = logging.getLogger('excel_splitter')

def validate_row(row, headers, header_row_idx, filters):
    """Проверяет соответствие строки условиям фильтров."""
    logger.debug(f"Validating row: {row}, headers: {headers}, filters: {filters}")
    
    if not filters:
        logger.debug("No filters provided, row is valid")
        return True
        
    # Нормализуем заголовки к нижнему регистру
    normalized_headers = [str(header).lower() if header is not None else "" for header in headers]
    
    for col, value in filters.items():
        # Нормализуем имя колонки к нижнему регистру
        normalized_col = str(col).lower()
        
        try:
            col_index = normalized_headers.index(normalized_col)
            cell_value = row[col_index] if col_index < len(row) else None
            str_value = str(cell_value).strip() if cell_value is not None else ""
            str_filter = str(value).strip()
            
            logger.debug(f"Checking column '{col}': cell value='{str_value}', filter='{str_filter}'")
            
            # Сравниваем без учета регистра
            if str_value.lower() != str_filter.lower():
                logger.debug(f"Row does not match filter for column '{col}'")
                return False
        except ValueError:
            logger.warning(f"Column '{col}' not found in headers")
            return False
    
    logger.debug("Row matches all filters")
    return True

─── FILE: excel_utils\filtering.py ───

from .analysis import analyze_column
import logging
logger = logging.getLogger('excel_splitter')

def get_all_combinations(source, valid_sheets, hierarchy_columns, filters=None, level=0):
    """Возвращает все возможные комбинации фильтров, включая частичные уровни."""
    if filters is None:
        filters = {}
    if level >= len(hierarchy_columns):
        return [filters.copy()]
    
    column = hierarchy_columns[level]
    categories = analyze_column(source, valid_sheets, column, filters)
    combinations = []
    
    # Добавляем комбинации для текущего уровня без добавления следующих уровней
    for category in categories:
        new_filters = filters.copy()
        new_filters[column] = category
        combinations.append(new_filters.copy())
    
    # Добавляем комбинации для следующих уровней
    for category in categories:
        new_filters = filters.copy()
        new_filters[column] = category
        combinations.extend(get_all_combinations(source, valid_sheets, hierarchy_columns, new_filters, level + 1))
    
    return combinations

def select_categories_sequentially(source, valid_sheets, hierarchy_columns):
    """Последовательно запрашивает выбор категорий у пользователя с отображением вариантов для каждой комбинации."""
    logger.info("Starting sequential category selection")
    all_combinations = []
    
    def generate_combinations(level, current_filters, include_all=False):
        """Рекурсивная функция генерации комбинаций"""
        if level >= len(hierarchy_columns):
            all_combinations.append(current_filters.copy())
            return
        
        column = hierarchy_columns[level]
        categories = analyze_column(source, valid_sheets, column, current_filters)
        if not categories:
            logger.warning(f"No categories found for column '{column}' at level {level}")
            return
        
        # Показываем текущие фильтры, если это не первый уровень
        if level > 0:
            print("\nCurrent filters:")
            for col, value in current_filters.items():
                print(f"  - {col}: {value}")
        
        # Выводим информацию о текущем уровне
        print(f"\n--- Level {level + 1}/{len(hierarchy_columns)} ---")
        print(f"Column for filtering: '{column}'")
        
        # Если это не последний уровень, спрашиваем, хочет ли пользователь выбрать все категории
        if level < len(hierarchy_columns) - 1:
            while True:
                all_choice = input(f"Include all categories for this level? (y/n): ").strip().lower()
                if all_choice == 'y':
                    # Обрабатываем выбор "all"
                    logger.info(f"User chose 'all' for column '{column}' at level {level}")
                    for category in categories:
                        new_filters = current_filters.copy()
                        new_filters[column] = category
                        generate_combinations(level + 1, new_filters, True)
                    return
                elif all_choice == 'n':
                    break
                else:
                    print("Please enter 'y' or 'n'")
        
        # Выводим доступные категории с номерами
        print(f"\nAvailable categories for column '{column}':")
        for i, cat in enumerate(categories, 1):
            print(f"  {i}. {cat}")
        
        print("  a. All (this level only)")
        print("  b. Назад")
        print("  c. Отмена")
        
        # Запрашиваем выбор
        while True:
            selection = input(f"Enter categories for '{column}' (comma-separated numbers, 'a' for all this level, 'b' for back, 'c' for cancel): ").strip()
            
            # Обработка специальных команд
            if selection.lower() in ["c", "cancel", "отмена"]:
                print("Operation cancelled by user")
                return
            if selection.lower() in ["b", "back", "назад"]:
                return
            
            # Обработка "all" (только для текущего уровня)
            if selection.lower() == "a":
                # Обрабатываем выбор "all" только для этого уровня
                logger.info(f"User chose 'all' for column '{column}' at level {level} (this level only)")
                for category in categories:
                    new_filters = current_filters.copy()
                    new_filters[column] = category
                    generate_combinations(level + 1, new_filters)
                return
            
            # Обработка номеров
            user_categories = []
            invalid_inputs = []
            for item in selection.split(","):
                item = item.strip()
                if item.isdigit():
                    idx = int(item) - 1
                    if 0 <= idx < len(categories):
                        user_categories.append(categories[idx])
                    else:
                        invalid_inputs.append(item)
                else:
                    user_categories.append(item)
            
            # Проверка валидности
            invalid_categories = [cat for cat in user_categories if cat not in categories]
            if invalid_categories or invalid_inputs:
                invalid_list = invalid_categories + invalid_inputs
                print(f"Error: Invalid categories: {', '.join(invalid_list)}")
                continue
            
            # Обработка выбора
            for category in user_categories:
                new_filters = current_filters.copy()
                new_filters[column] = category
                generate_combinations(level + 1, new_filters)
            
            return
    
    # Начинаем генерацию комбинаций с первого уровня
    generate_combinations(0, {})
    
    # Возвращаем уникальные комбинации
    unique_combinations = []
    seen = set()
    for filters in all_combinations:
        filter_tuple = tuple(sorted(filters.items()))
        if filter_tuple not in seen:
            seen.add(filter_tuple)
            unique_combinations.append(filters)
    
    return unique_combinations

─── FILE: excel_utils\formatting.py ───

import re
import os
import logging
from openpyxl.utils import get_column_letter
logger = logging.getLogger('excel_splitter')

def sanitize_filename(name):
    """Удаляет недопустимые символы из названия файла."""
    # Удаляем недопустимые символы
    name = re.sub(r'[\\/*?:"<>|]', '_', name)
    # Убираем лишние пробелы
    name = re.sub(r'\s+', ' ', name).strip()
    return name

def shorten_category_name(name):
    """
    Сокращает длинные названия категорий по правилам:
    - Для одного слова: первые 3 буквы
    - Для двух и более слов: первая буква каждого слова
    """
    if not name:
        return ""
    
    # Удаляем недопустимые символы
    name = sanitize_filename(name)
    
    # Если название короткое, оставляем как есть
    if len(name) <= 15:
        return name
    
    # Разбиваем на слова
    words = name.split()
    if len(words) > 1:
        # Берем первую букву каждого слова
        short_name = ''.join(word[0] for word in words if word)
    else:
        # Для одного слова берем первые 3 буквы
        short_name = name[:3]
    
    return short_name

def generate_short_filename(base_name, filters, max_length=150, is_folder_hierarchy=False):
    """
    Генерирует короткое имя файла с учетом максимальной длины.
    Если длина превышает max_length, использует хэш для уникальности.
    
    Параметры:
    base_name (str): Базовое имя файла
    filters (dict): Фильтры для генерации названия
    max_length (int): Максимальная длина пути к файлу
    is_folder_hierarchy (bool): Признак использования иерархии папок
    
    Возвращает:
    str: Сгенерированное короткое имя файла
    """
    # Создаем список сокращенных названий категорий
    safe_parts = []
    for i, (col, value) in enumerate(filters.items()):
        if i == len(filters) - 1:  # Последняя категория - не сокращаем
            safe_parts.append(sanitize_filename(value))
        else:
            safe_parts.append(shorten_category_name(value))
    
    # Формируем суффикс
    suffix = "_".join(safe_parts) if safe_parts else "All"
    
    # Проверяем длину полного пути
    full_path = os.path.join(os.path.dirname(base_name), f"{os.path.basename(base_name)}_{suffix}.xlsx")
    
    # Если длина слишком большая, сокращаем
    if len(full_path) > max_length:
        logger.warning(f"Filename is too long ({len(full_path)} characters), shortening...")
        # Оставляем только последние N символов из суффикса
        max_suffix_length = max_length - len(base_name) - 5  # Учитываем '.xlsx' и '_'
        
        if max_suffix_length <= 0:
            # Если даже базовое имя слишком длинное, используем хэш
            import hashlib
            hash_suffix = hashlib.sha1(suffix.encode()).hexdigest()[:8]
            suffix = f"short_{hash_suffix}"
        else:
            # Сокращаем суффикс до допустимой длины
            suffix = suffix[:max_suffix_length]
    
    return f"{os.path.basename(base_name)}_{suffix}.xlsx"

─── FILE: excel_utils\workbook.py ───

import os
import re
import logging
import openpyxl
from copy import copy
from contextlib import contextmanager
from openpyxl.worksheet.table import Table, TableStyleInfo
from excel_utils.common import validate_row
logger = logging.getLogger('excel_splitter')

def get_column_letter(col_idx):
    """Конвертирует индекс столбца в букву (1 -> A, 26 -> Z, 27 -> AA и т.д.)"""
    letters = []
    while col_idx > 0:
        col_idx, remainder = divmod(col_idx - 1, 26)
        letters.append(chr(65 + remainder))
    return ''.join(reversed(letters))

def clean_table_name(name):
    """Очищает имя таблицы от недопустимых символов и пробелов."""
    # Удаляем недопустимые символы
    clean_name = re.sub(r'[^\w]', '', name)
    # Если имя слишком длинное, сокращаем его
    if len(clean_name) > 31:
        clean_name = clean_name[:31]
    # Если имя пустое, возвращаем дефолтное имя
    if not clean_name:
        return "Table"
    return clean_name

def is_openpyxl_new_version():
    """Проверяет, является ли версия openpyxl новой (>= 3.0)"""
    try:
        from openpyxl import __version__
        major_version = int(__version__.split('.')[0])
        return major_version >= 3
    except (ImportError, ValueError):
        return False

@contextmanager
def safe_workbook(file_path, read_only=False):
    """Контекстный менеджер для безопасной работы с файлами Excel."""
    wb = None
    try:
        logger.debug(f"Opening workbook: {file_path}")
        wb = openpyxl.load_workbook(file_path, read_only=read_only)
        yield wb
    finally:
        if wb:
            try:
                wb.close()
                logger.debug(f"Workbook closed: {file_path}")
            except Exception as e:
                logger.error(f"Error closing workbook: {str(e)}")

def create_filtered_file(source, target, valid_sheets, filters):
    """Создаёт файл с фильтрацией по комбинации условий."""
    logger.info(f"Creating filtered file: {target} with filters {filters}")
    
    # Добавлена проверка на пустой фильтр
    if not filters:
        logger.info("Empty filters, copying all data")
    
    try:
        # Всегда сохраняем как .xlsx
        if target.lower().endswith('.xlsm'):
            logger.debug("Converting .xlsm to .xlsx format")
            target = target[:-5] + '.xlsx'
        
        with safe_workbook(source, read_only=False) as wb_source:
            wb_new = openpyxl.Workbook()
            wb_new.remove(wb_new.active)
            has_data = False  # Флаг наличия данных
            logger.debug(f"Processing {len(wb_source.sheetnames)} sheets")
            
            for sheet_name in wb_source.sheetnames:
                ws_source = wb_source[sheet_name]
                # Игнорируем скрытые листы
                if ws_source.sheet_state != 'visible':
                    logger.debug(f"Skipping hidden sheet: {sheet_name}")
                    continue
                
                ws_new = wb_new.create_sheet(title=sheet_name)
                logger.debug(f"Processing sheet: {sheet_name}")
                
                # Копирование ширины столбцов
                if hasattr(ws_source, 'column_dimensions'):
                    for col_letter, dim in ws_source.column_dimensions.items():
                        try:
                            ws_new.column_dimensions[col_letter].width = dim.width
                        except Exception as e:
                            logger.debug(f"Error copying column width for {col_letter}: {str(e)}")
                
                # Копирование высоты строк
                if hasattr(ws_source, 'row_dimensions'):
                    for row_idx, dim in ws_source.row_dimensions.items():
                        try:
                            ws_new.row_dimensions[row_idx].height = dim.height
                        except Exception as e:
                            logger.debug(f"Error copying row height for {row_idx}: {str(e)}")
                
                # Копирование объединенных ячеек
                if hasattr(ws_source, 'merged_cells'):
                    for merged_cell in ws_source.merged_cells.ranges:
                        try:
                            ws_new.merge_cells(str(merged_cell))
                        except Exception as e:
                            logger.debug(f"Error copying merged cells: {str(e)}")
                
                # Копирование условного форматирования
                if hasattr(ws_source, 'conditional_formatting'):
                    for cf in ws_source.conditional_formatting:
                        try:
                            # Определяем, какой метод использовать для получения диапазона
                            range_attr = '_get_range' if hasattr(cf, '_get_range') else 'ref'
                            range_value = getattr(cf, range_attr, None) or cf._range
                            
                            # Определяем, какой тип правил используем
                            if hasattr(cf, 'cfRule') and hasattr(cf, 'cfRules'):
                                # Новые версии openpyxl
                                for rule in cf.cfRules:
                                    try:
                                        ws_new.conditional_formatting.add(range_value, rule)
                                    except Exception as e:
                                        logger.debug(f"Error adding rule in new format: {str(e)}")
                            elif hasattr(cf, 'rules'):
                                # Средние версии
                                for rule in cf.rules:
                                    try:
                                        ws_new.conditional_formatting.add(range_value, rule)
                                    except Exception as e:
                                        logger.debug(f"Error adding rule in medium format: {str(e)}")
                            else:
                                # Старые версии
                                try:
                                    ws_new.conditional_formatting.add(range_value, cf)
                                except Exception as e:
                                    logger.debug(f"Error adding rule in old format: {str(e)}")
                        except Exception as e:
                            logger.debug(f"Error copying conditional formatting: {str(e)}")
                
                if sheet_name in valid_sheets:
                    headers, header_row_idx = valid_sheets[sheet_name]
                    logger.debug(f"Headers for sheet {sheet_name}: {headers}")
                    logger.debug(f"Header row index: {header_row_idx}")
                    
                    # 1. Технические строки выше таблицы
                    for row_idx in range(1, header_row_idx):
                        for col_idx in range(1, ws_source.max_column + 1):
                            try:
                                cell = ws_source.cell(row=row_idx, column=col_idx)
                                if cell.value is not None or cell.has_style:
                                    new_cell = ws_new.cell(row=row_idx, column=col_idx, value=cell.value)
                                    if cell.has_style:
                                        # Копируем отдельные стили вместо общего
                                        try:
                                            new_cell.font = copy(cell.font)
                                            new_cell.border = copy(cell.border)
                                            new_cell.fill = copy(cell.fill)
                                            new_cell.alignment = copy(cell.alignment)
                                            new_cell.number_format = cell.number_format
                                        except Exception as e:
                                            logger.debug(f"Error copying individual style properties: {str(e)}")
                            except Exception as e:
                                logger.debug(f"Error copying cell at row {row_idx}, col {col_idx}: {str(e)}")
                    
                    # 2. Заголовки
                    for col_idx in range(1, ws_source.max_column + 1):
                        try:
                            cell = ws_source.cell(row=header_row_idx, column=col_idx)
                            if cell.value is not None or cell.has_style:
                                new_cell = ws_new.cell(row=header_row_idx, column=col_idx, value=cell.value)
                                if cell.has_style:
                                    # Копируем отдельные стили вместо общего
                                    try:
                                        new_cell.font = copy(cell.font)
                                        new_cell.border = copy(cell.border)
                                        new_cell.fill = copy(cell.fill)
                                        new_cell.alignment = copy(cell.alignment)
                                        new_cell.number_format = cell.number_format
                                    except Exception as e:
                                        logger.debug(f"Error copying individual style properties for header: {str(e)}")
                        except Exception as e:
                            logger.debug(f"Error copying header at col {col_idx}: {str(e)}")
                    
                    # 3. Фильтрация данных
                    new_row_idx = header_row_idx + 1
                    filtered_count = 0
                    for row_idx in range(header_row_idx + 1, ws_source.max_row + 1):
                        try:
                            row = ws_source[row_idx]
                            # Добавлена проверка на пустой фильтр
                            if not filters:
                                should_include = True
                            else:
                                should_include = validate_row([cell.value for cell in row], headers, header_row_idx, filters)
                            
                            if should_include:
                                filtered_count += 1
                                for col_idx in range(1, ws_source.max_column + 1):
                                    try:
                                        source_cell = ws_source.cell(row=row_idx, column=col_idx)
                                        if source_cell.value is not None or source_cell.has_style:
                                            new_cell = ws_new.cell(row=new_row_idx, column=col_idx, value=source_cell.value)
                                            if source_cell.has_style:
                                                # Копируем отдельные стили вместо общего
                                                try:
                                                    new_cell.font = copy(source_cell.font)
                                                    new_cell.border = copy(source_cell.border)
                                                    new_cell.fill = copy(source_cell.fill)
                                                    new_cell.alignment = copy(source_cell.alignment)
                                                    new_cell.number_format = source_cell.number_format
                                                except Exception as e:
                                                    logger.debug(f"Error copying individual style properties for data cell: {str(e)}")
                                    except Exception as e:
                                        logger.debug(f"Error copying data cell at row {row_idx}, col {col_idx}: {str(e)}")
                                new_row_idx += 1
                        except Exception as e:
                            logger.debug(f"Error processing row {row_idx}: {str(e)}")
                    
                    logger.debug(f"Filtered {filtered_count} rows out of {ws_source.max_row - header_row_idx} possible")
                    
                    # Проверка наличия данных
                    if new_row_idx > header_row_idx + 1:
                        has_data = True
                        # Форматируем данные как таблицу
                        last_col = 0
                        for col_idx in range(1, ws_source.max_column + 1):
                            # Проверяем, есть ли данные в этой колонке
                            has_data_in_col = False
                            for row_idx in range(header_row_idx, new_row_idx):
                                if ws_new.cell(row=row_idx, column=col_idx).value is not None:
                                    has_data_in_col = True
                                    break
                            if has_data_in_col:
                                last_col = col_idx
                        
                        # Если не определили последнюю колонку, используем max_column
                        if last_col == 0:
                            last_col = ws_source.max_column
                        
                        last_col_letter = get_column_letter(last_col)
                        data_start_row = header_row_idx + 1
                        data_end_row = new_row_idx - 1
                        table_range = f"A{header_row_idx}:{last_col_letter}{data_end_row}"
                        
                        # Создаем таблицу с безопасным именем
                        safe_table_name = clean_table_name(sheet_name)
                        table = Table(displayName=safe_table_name, ref=table_range)
                        
                        # Создаем стиль таблицы с только поддерживаемыми параметрами
                        try:
                            # Пытаемся создать стиль с минимально необходимыми параметрами
                            style = TableStyleInfo(
                                name="TableStyleLight1",
                                showFirstColumn=False,
                                showLastColumn=False,
                                showColumnHeaders=True
                            )
                            table.tableStyleInfo = style
                        except TypeError as e:
                            logger.warning(f"TableStyleInfo parameters not fully supported: {str(e)}")
                            try:
                                style = TableStyleInfo(
                                    name="TableStyleLight1",
                                    showColumnHeaders=True
                                )
                                table.tableStyleInfo = style
                            except TypeError:
                                logger.warning("Using minimal table style")
                                style = TableStyleInfo(name="TableStyleLight1")
                                table.tableStyleInfo = style
                        
                        ws_new.add_table(table)
                    else:
                        # Удаляем лист без данных
                        wb_new.remove(ws_new)
                        logger.debug(f"Removed sheet {sheet_name} due to no matching data")
                        continue  # Переходим к следующему листу
                
                else:
                    logger.debug(f"Copying entire sheet {sheet_name} without filtering")
                    for row_idx in range(1, ws_source.max_row + 1):
                        for col_idx in range(1, ws_source.max_column + 1):
                            try:
                                cell = ws_source.cell(row=row_idx, column=col_idx)
                                if cell.value is not None or cell.has_style:
                                    new_cell = ws_new.cell(row=row_idx, column=col_idx, value=cell.value)
                                    if cell.has_style:
                                        # Копируем отдельные стили вместо общего
                                        try:
                                            new_cell.font = copy(cell.font)
                                            new_cell.border = copy(cell.border)
                                            new_cell.fill = copy(cell.fill)
                                            new_cell.alignment = copy(cell.alignment)
                                            new_cell.number_format = cell.number_format
                                        except Exception as e:
                                            logger.debug(f"Error copying individual style properties: {str(e)}")
                            except Exception as e:
                                logger.debug(f"Error copying cell at row {row_idx}, col {col_idx}: {str(e)}")
            
            if not has_data:
                logger.warning("No data matched the filters, file not created")
                return None
            
            # Удаляем целевой файл, если он существует
            if os.path.exists(target):
                logger.info(f"Removing existing target file: {target}")
                os.remove(target)
            
            # Сохраняем как .xlsx
            logger.info(f"Saving filtered file: {target}")
            wb_new.save(target)
            return target
    except Exception as e:
        logger.exception(f"Error during filtering: {str(e)}")
        raise ValueError(f"Error during filtering: {str(e)}")

─── FILE: excel_utils\__init__.py ───

# Импорты для пакета excel_utils
try:
    from .analysis import get_all_sheets_headers, analyze_column
    from .filtering import get_all_combinations, select_categories_sequentially
    from .formatting import sanitize_filename, generate_short_filename
    from .workbook import create_filtered_file
    from .common import validate_row
    
    __all__ = [
        'get_all_sheets_headers',
        'analyze_column',
        'get_all_combinations',
        'select_categories_sequentially',
        'sanitize_filename',
        'generate_short_filename',
        'create_filtered_file',
        'validate_row'
    ]
    
    # Убираем логгирование из __init__.py
    # Логгирование должно происходить в main.py после полной инициализации
except Exception as e:
    # Добавляем импорт logging ДО использования
    import logging
    logger = logging.getLogger('excel_splitter')
    logger.error(f"Failed to initialize excel_utils package: {str(e)}")
    raise

─── FILE: gui\main.py ───

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import logging
import os
from core.processing import process_file
from excel_utils.analysis import get_all_sheets_headers
from excel_utils.filtering import select_categories_sequentially

logger = logging.getLogger('excel_splitter')

class ExcelSplitterGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Excel Splitter")
        self.root.geometry("800x600")
        
        # Инициализируем переменные
        self.source_file = tk.StringVar()
        self.destination_folder = tk.StringVar()
        self.columns = []
        self.selected_columns = []
        self.filters = {}
        self.valid_sheets = {}
        
        self.create_widgets()
        
    def create_widgets(self):
        """Создает элементы интерфейса"""
        # Основной фрейм
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Фрейм для выбора файлов
        file_frame = ttk.LabelFrame(main_frame, text="File Selection", padding="10")
        file_frame.pack(fill=tk.X, pady=5)
        
        # Выбор исходного файла
        ttk.Label(file_frame, text="Source Excel File:").grid(row=0, column=0, sticky=tk.W, pady=2)
        ttk.Entry(file_frame, textvariable=self.source_file, width=70).grid(row=0, column=1, padx=5, pady=2)
        ttk.Button(file_frame, text="Browse", command=self.browse_source).grid(row=0, column=2, padx=5, pady=2)
        
        # Выбор целевой папки
        ttk.Label(file_frame, text="Destination Folder:").grid(row=1, column=0, sticky=tk.W, pady=2)
        ttk.Entry(file_frame, textvariable=self.destination_folder, width=70).grid(row=1, column=1, padx=5, pady=2)
        ttk.Button(file_frame, text="Browse", command=self.browse_destination).grid(row=1, column=2, padx=5, pady=2)
        
        # Фрейм для колонок
        columns_frame = ttk.LabelFrame(main_frame, text="Filter Columns", padding="10")
        columns_frame.pack(fill=tk.X, pady=5)
        
        # Кнопка анализа файла
        ttk.Button(columns_frame, text="Analyze File", command=self.analyze_file).pack(side=tk.LEFT, padx=5)
        
        # Список колонок
        columns_label = ttk.Label(columns_frame, text="Available columns:")
        columns_label.pack(side=tk.LEFT, padx=5)
        
        # Фрейм для логов
        log_frame = ttk.LabelFrame(main_frame, text="Processing Log", padding="10")
        log_frame.pack(fill=tk.BOTH, expand=True, pady=5)
        
        # Текстовое поле для логов
        self.log_text = tk.Text(log_frame, height=10, wrap=tk.WORD)
        self.log_text.pack(fill=tk.BOTH, expand=True)
        
        # Добавляем скроллбар
        scrollbar = ttk.Scrollbar(self.log_text, command=self.log_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.log_text.config(yscrollcommand= scrollbar.set)
        
        # Кнопки управления
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=5)
        
        ttk.Button(button_frame, text="Run", command=self.run_processing).pack(side=tk.RIGHT, padx=5)
        ttk.Button(button_frame, text="Clear", command=self.clear_log).pack(side=tk.RIGHT, padx=5)
    
    def log(self, message):
        """Записывает сообщение в лог-окно"""
        self.log_text.insert(tk.END, message + "\n")
        self.log_text.see(tk.END)
    
    def browse_source(self):
        """Открывает диалог выбора исходного файла"""
        file_path = filedialog.askopenfilename(
            title="Select Source Excel File",
            filetypes=[("Excel Files", "*.xlsx *.xlsm")]
        )
        if file_path:
            self.source_file.set(file_path)
    
    def browse_destination(self):
        """Открывает диалог выбора целевой папки"""
        folder_path = filedialog.askdirectory(title="Select Destination Folder")
        if folder_path:
            self.destination_folder.set(folder_path)
    
    def analyze_file(self):
        """Анализирует файл и показывает доступные колонки"""
        source = self.source_file.get()
        if not source or not os.path.exists(source):
            messagebox.showerror("Error", "Please select a valid source file")
            return
            
        try:
            # Анализируем файл
            self.log(f"Analyzing file: {source}")
            sheet_headers = get_all_sheets_headers(source)
            self.valid_sheets = {sheet: data for sheet, data in sheet_headers.items() if data[0] is not None}
            
            if not self.valid_sheets:
                self.log("Error: No headers found in any sheet")
                return
                
            # Поиск пересечения заголовков
            all_headers = [set(headers) for headers, _ in self.valid_sheets.values()]
            common_headers = set.intersection(*all_headers) if all_headers else set()
            
            if not common_headers:
                self.log("Warning: No common headers found between sheets")
                return
                
            # Отображаем колонки
            self.columns = list(common_headers)
            self.log(f"Found {len(self.columns)} common columns:")
            for i, col in enumerate(self.columns, 1):
                self.log(f"  {i}. {col}")
                
        except Exception as e:
            self.log(f"Error analyzing file: {str(e)}")
    
    def run_processing(self):
        """Запускает обработку файла"""
        source = self.source_file.get()
        destination = self.destination_folder.get()
        
        if not source or not os.path.exists(source):
            messagebox.showerror("Error", "Please select a valid source file")
            return
            
        if not destination or not os.path.isdir(destination):
            messagebox.showerror("Error", "Please select a valid destination folder")
            return
        
        try:
            # Имитируем процесс обработки
            self.log("Starting file processing...")
            
            # Временно сохраняем стандартный вывод
            import sys
            original_stdout = sys.stdout
            from io import StringIO
            sys.stdout = StringIO()
            
            # Запускаем основную функцию обработки
            success = process_file()
            
            # Получаем вывод
            output = sys.stdout.getvalue()
            sys.stdout = original_stdout
            
            # Отображаем результаты
            self.log("Processing completed!")
            if success:
                self.log("Operation was successful")
            else:
                self.log("Operation failed")
            
            # Показываем сообщение об успехе
            if success:
                messagebox.showinfo("Success", "File processing completed successfully!")
            else:
                messagebox.showerror("Error", "File processing failed")
                
        except Exception as e:
            self.log(f"Unexpected error: {str(e)}")
            messagebox.showerror("Error", f"Unexpected error: {str(e)}")
    
    def clear_log(self):
        """Очищает лог-окно"""
        self.log_text.delete(1.0, tk.END)

def launch_gui():
    """Запускает графический интерфейс"""
    root = tk.Tk()
    app = ExcelSplitterGUI(root)
    root.mainloop()

if __name__ == "__main__":
    launch_gui()

─── FILE: gui\__init__.py ───

# Импорты для пакета gui
from .main import launch_gui
__all__ = ['launch_gui']

─── FILE: tests\test_analysis.py ───

import unittest
from excel_utils.analysis import get_all_sheets_headers, analyze_column
from excel_utils.common import validate_row
import os
import tempfile

class TestExcelAnalysis(unittest.TestCase):
    def setUp(self):
        # Создаем тестовый Excel-файл
        self.temp_dir = tempfile.mkdtemp()
        self.test_file = os.path.join(self.temp_dir, "test.xlsx")
        
        from openpyxl import Workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Sheet1"
        ws.append(["Header1", "Header2", "Header3"])
        ws.append(["Data1", "ValueA", "100"])
        ws.append(["Data2", "ValueB", "200"])
        ws.append(["Data3", "ValueA", "300"])
        wb.save(self.test_file)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_get_all_sheets_headers(self):
        """Проверяет корректность определения заголовков в Excel-файле"""
        headers = get_all_sheets_headers(self.test_file)
        self.assertIn("Sheet1", headers)
        self.assertEqual(headers["Sheet1"][0], ["Header1", "Header2", "Header3"])
    
    def test_analyze_column(self):
        """Проверяет сбор уникальных значений из колонки"""
        headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in headers.items() if v[0] is not None}
        
        categories = analyze_column(self.test_file, valid_sheets, "Header2")
        self.assertEqual(categories, ["ValueA", "ValueB"])
    
    def test_validate_row(self):
        """Проверяет фильтрацию строк по условиям"""
        headers = ["Header1", "Header2", "Header3"]
        row = ["Data1", "ValueA", "100"]
        
        # Проверяем фильтр по одной колонке
        self.assertTrue(validate_row(row, headers, 1, {"Header2": "ValueA"}))
        self.assertFalse(validate_row(row, headers, 1, {"Header2": "ValueB"}))
        
        # Проверяем фильтр по нескольким колонкам
        self.assertTrue(validate_row(row, headers, 1, {"Header1": "Data1", "Header2": "ValueA"}))
        self.assertFalse(validate_row(row, headers, 1, {"Header1": "Data1", "Header2": "ValueB"}))

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_filename_shortening.py ───

import unittest
import os
import tempfile
from excel_utils.formatting import sanitize_filename, shorten_category_name, generate_short_filename

class TestFilenameShortening(unittest.TestCase):
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_sanitize_filename(self):
        """Проверяет удаление недопустимых символов из названия файла"""
        self.assertEqual(sanitize_filename("Test:File?Name*"), "Test_File_Name_")
        self.assertEqual(sanitize_filename("File with spaces"), "File with spaces")
        self.assertEqual(sanitize_filename("File<>|"), "File____")
    
    def test_shorten_category_name(self):
        """Проверяет сокращение названий категорий по новым правилам"""
        # Проверка с предлогами
        self.assertEqual(shorten_category_name("Отдел по учету и налогам"), "ОУиН")
        self.assertEqual(shorten_category_name("Департамент по развитию и инвестициям"), "ДРиИ")
        self.assertEqual(shorten_category_name("Управление для анализа и контроля"), "УАиК")
        
        # Проверка союзов
        self.assertEqual(shorten_category_name("Технический директорат и управление"), "ТДиУ")
        self.assertEqual(shorten_category_name("Департамент развития или анализа"), "ДРиА")
        self.assertEqual(shorten_category_name("Отдел учета а также контроля"), "ОУаК")
        
        # Проверка коротких результатов
        self.assertEqual(shorten_category_name("Кадровый директорат"), "КаД")
        self.assertEqual(shorten_category_name("Департамент анализа"), "ДаА")
        self.assertEqual(shorten_category_name("Управление"), "Уп")
        
        # Проверка дефисов
        self.assertEqual(shorten_category_name("Финансово-инвестиционный департамент"), "ФИД")
        self.assertEqual(shorten_category_name("Техническо-инженерный отдел"), "ТИО")
        self.assertEqual(shorten_category_name("Административно-хозяйственный отдел"), "АХО")
        
        # Проверка последней категории (не сокращается)
        self.assertEqual(shorten_category_name("Кадровый директорат", is_last=True), "Кадровый директорат")
        self.assertEqual(shorten_category_name("Департамент развития", is_last=True), "Департамент развития")
        self.assertEqual(shorten_category_name("Отдел учета", is_last=True), "Отдел учета")
        
        # Проверка обработки регистра
        self.assertEqual(shorten_category_name("ТЕХНИЧЕСКИЙ ДИРЕКТОРАТ"), "ТеД")
        self.assertEqual(shorten_category_name("департамент развития"), "ДеР")
        self.assertEqual(shorten_category_name("отдел учета"), "ОУ")
    
    def test_generate_short_filename(self):
        """Проверяет генерацию коротких имен файлов с новыми правилами"""
        # Базовый случай с одной категорией
        base_path = os.path.join(self.temp_dir, "base_file")
        filters = {"Department": "Human Resources"}
        filename = generate_short_filename(base_path, filters)
        self.assertEqual(filename, "base_file_Human Resources.xlsx")
        
        # Сценарий с несколькими категориями
        filters = {
            "Department": "Технический директорат",
            "Team": "Департамент по развитию",
            "Project": "Отдел по ремонту"
        }
        filename = generate_short_filename(base_path, filters)
        self.assertEqual(filename, "base_file_ТеД_ДР_Отдел по ремонту.xlsx")
        
        # Проверка обработки регистра
        filters = {
            "Department": "ТЕХНИЧЕСКИЙ ДИРЕКТОРАТ",
            "Team": "ДЕПАРТАМЕНТ ПО РАЗВИТИЮ",
            "Project": "ОТДЕЛ ПО РЕМОНТУ"
        }
        filename = generate_short_filename(base_path, filters)
        self.assertEqual(filename, "base_file_ТеД_ДР_ОТДЕЛ ПО РЕМОНТУ.xlsx")
        
        # Проверка длины пути
        base_path = os.path.join(self.temp_dir, "very_long_base_name" * 10)
        filters = {
            "Department": "Технический директорат" * 10,
            "Team": "Департамент по развитию" * 10
        }
        filename = generate_short_filename(base_path, filters)
        self.assertTrue(len(filename) <= 200)
        
        # Проверка хэширования при очень длинных именах
        base_path = os.path.join(self.temp_dir, "a" * 200)
        filters = {
            "Department": "b" * 200,
            "Team": "c" * 200
        }
        filename = generate_short_filename(base_path, filters)
        self.assertIn("short_", filename)
        self.assertEqual(len(filename), 200)

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_filtering.py ───

import unittest
import os
import tempfile
import openpyxl
from excel_utils.filtering import select_categories_sequentially, get_all_combinations
from excel_utils.analysis import get_all_sheets_headers

class TestFiltering(unittest.TestCase):
    def setUp(self):
        # Создаем тестовый Excel-файл
        self.temp_dir = tempfile.mkdtemp()
        self.test_file = os.path.join(self.temp_dir, "test_data.xlsx")
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "TestSheet"
        
        # Добавляем заголовки
        ws.append(["Department", "Subdivision", "Position"])
        
        # Добавляем данные
        data = [
            ["Department A", "Subdivision A1", "Position A1"],
            ["Department A", "Subdivision A1", "Position A2"],
            ["Department A", "Subdivision A2", "Position A3"],
            ["Department B", "Subdivision B1", "Position B1"],
            ["Department B", "Subdivision B1", "Position B2"],
            ["Department B", "Subdivision B2", "Position B3"],
            ["Department B", "Subdivision B2", "Position B4"]
        ]
        
        for row in data:
            ws.append(row)
        
        wb.save(self.test_file)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_all_mode_first_level(self):
        """Проверяет выбор 'all' на первом уровне"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Выбираем колонки в порядке иерархии
        hierarchy_columns = ["Department", "Subdivision", "Position"]
        
        # Вместо интерактивного ввода, проверяем логику генерации
        combinations = select_categories_sequentially(self.test_file, valid_sheets, hierarchy_columns)
        
        # Ожидаемые комбинации для "all" на первом уровне:
        # 2 департамента * (2 подразделения для A + 2 подразделения для B) * (2 позиции для A1 + 1 позиция для A2 + 2 позиции для B1 + 2 позиции для B2)
        # Но так как мы выбрали "all" только для первого уровня, а остальные уровни не обрабатывались
        # В данном тесте мы проверяем, что функция работает корректно
        
        # В реальной ситуации, если бы мы выбрали "all" на первом уровне, мы бы получили 2 комбинации (два департамента)
        self.assertTrue(len(combinations) > 0)
    
    def test_all_mode_second_level(self):
        """Проверяет выбор 'all' на втором уровне"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Выбираем колонки в порядке иерархии
        hierarchy_columns = ["Department", "Subdivision", "Position"]
        
        # Симулируем выбор: Department A -> all Subdivisions
        def mock_select_categories_sequentially(source, valid_sheets, hierarchy_columns):
            # Создаем фильтры для Department A
            filters = {"Department": "Department A"}
            
            # Генерируем комбинации для Subdivision
            combinations = []
            subdivisions = ["Subdivision A1", "Subdivision A2"]
            for subdivision in subdivisions:
                new_filters = filters.copy()
                new_filters["Subdivision"] = subdivision
                combinations.append(new_filters)
            return combinations
        
        # Используем подменную функцию для тестирования
        combinations = mock_select_categories_sequentially(self.test_file, valid_sheets, hierarchy_columns)
        
        # Проверяем, что мы получили обе подразделения для департамента A
        self.assertEqual(len(combinations), 2)
        self.assertEqual(combinations[0]["Subdivision"], "Subdivision A1")
        self.assertEqual(combinations[1]["Subdivision"], "Subdivision A2")
    
    def test_mixed_mode(self):
        """Проверяет смешанный режим (точечный выбор на одних уровнях, 'all' на других)"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Выбираем колонки в порядке иерархии
        hierarchy_columns = ["Department", "Subdivision", "Position"]
        
        # Симулируем выбор: Department A -> Subdivision A1 -> all Positions
        def mock_select_categories_sequentially(source, valid_sheets, hierarchy_columns):
            # Создаем фильтры
            filters = {
                "Department": "Department A",
                "Subdivision": "Subdivision A1"
            }
            
            # Генерируем комбинации для Position
            positions = ["Position A1", "Position A2"]
            return [{"Department": "Department A", "Subdivision": "Subdivision A1", "Position": pos} for pos in positions]
        
        # Используем подменную функцию для тестирования
        combinations = mock_select_categories_sequentially(self.test_file, valid_sheets, hierarchy_columns)
        
        # Проверяем, что мы получили все позиции для Subdivision A1
        self.assertEqual(len(combinations), 2)
        self.assertEqual(combinations[0]["Position"], "Position A1")
        self.assertEqual(combinations[1]["Position"], "Position A2")
    
    def test_no_matching_data(self):
        """Проверяет поведение при отсутствии данных"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Выбираем колонки в порядке иерархии
        hierarchy_columns = ["Department", "Subdivision", "Position"]
        
        # Симулируем выбор несуществующей категории
        def mock_select_categories_sequentially(source, valid_sheets, hierarchy_columns):
            # Создаем фильтры для несуществующего департамента
            return []
        
        # Используем подменную функцию для тестирования
        combinations = mock_select_categories_sequentially(self.test_file, valid_sheets, hierarchy_columns)
        
        # Проверяем, что возвращается пустой список
        self.assertEqual(len(combinations), 0)

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_imports.py ───

import unittest
import sys
import os

# Добавляем корневую директорию проекта в путь для импорта
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

class TestModuleImports(unittest.TestCase):
    """Тест на проверку корректности импортов модулей"""
    
    def test_import_main(self):
        """Проверяет, что main.py импортируется без ошибок"""
        try:
            import main
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import main: {str(e)}")
    
    def test_import_cli(self):
        """Проверяет, что cli модуль импортируется без ошибок"""
        try:
            from cli import interface
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import cli: {str(e)}")
    
    def test_import_core(self):
        """Проверяет, что core модуль импортируется без ошибок"""
        try:
            from core import processing
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import core: {str(e)}")
    
    def test_import_excel_utils(self):
        """Проверяет, что excel_utils модуль импортируется без ошибок"""
        try:
            from excel_utils import (
                analysis, 
                filtering, 
                formatting, 
                workbook,
                get_all_sheets_headers,
                analyze_column,
                get_all_combinations,
                select_categories_sequentially,
                sanitize_filename,
                generate_short_filename,
                create_filtered_file
            )
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import excel_utils: {str(e)}")
    
    def test_import_specific_functions(self):
        """Проверяет доступность конкретных функций через пакетный импорт"""
        try:
            from excel_utils import (
                generate_short_filename,
                create_filtered_file
            )
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import specific functions: {str(e)}")

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_module_initialization.py ───

import unittest
import sys
import os
import logging

# Добавляем корневую директорию проекта в путь для импорта
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

class TestModuleInitialization(unittest.TestCase):
    """Тест на проверку корректной инициализации всех модулей"""
    
    def setUp(self):
        # Настройка логгера для тестов
        logging.basicConfig(level=logging.DEBUG)
        self.logger = logging.getLogger('test_initialization')
    
    def test_excel_utils_initialization(self):
        """Проверяет, что пакет excel_utils инициализируется без ошибок"""
        try:
            import excel_utils
            self.assertIsNotNone(excel_utils)
            self.logger.debug("excel_utils package imported successfully")
        except Exception as e:
            self.fail(f"Failed to import excel_utils package: {str(e)}")
    
    def test_all_modules_import(self):
        """Проверяет импорт всех модулей проекта"""
        modules = [
            'excel_utils.analysis',
            'excel_utils.filtering',
            'excel_utils.formatting',
            'excel_utils.workbook',
            'excel_utils.common',
            'core.processing',
            'cli.interface'
        ]
        
        for module in modules:
            try:
                __import__(module)
                self.logger.debug(f"Successfully imported {module}")
            except Exception as e:
                self.fail(f"Failed to import {module}: {str(e)}")
    
    def test_function_availability(self):
        """Проверяет доступность критических функций"""
        try:
            from excel_utils.formatting import generate_short_filename
            self.assertTrue(callable(generate_short_filename))
            
            from excel_utils.common import validate_row
            self.assertTrue(callable(validate_row))
            
            from excel_utils.workbook import create_filtered_file
            self.assertTrue(callable(create_filtered_file))
        except Exception as e:
            self.fail(f"Critical functions not available: {str(e)}")

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_special_formats.py ───

import unittest
import os
import tempfile
import openpyxl
from excel_utils.workbook import create_filtered_file
from excel_utils.analysis import get_all_sheets_headers

class TestSpecialFormatting(unittest.TestCase):
    def setUp(self):
        # Создаем тестовый Excel-файл с особыми стилями
        self.temp_dir = tempfile.mkdtemp()
        self.test_file = os.path.join(self.temp_dir, "test_special.xlsx")
        
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "TestSheet"
        
        # Добавляем заголовки
        ws.append(["ID", "Золотой работник", "Category", "Other"])
        
        # Добавляем данные
        ws.append([1, "да", "A", "Data"])
        ws.append([2, "нет", "B", "Data"])
        ws.append([3, "запланирован", "A", "Data"])
        ws.append([4, "пробел", "B", "Data"])
        ws.append([5, "другое значение", "A", "Data"])
        
        wb.save(self.test_file)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_golden_worker_formatting(self):
        """Проверяет специфическое форматирование для колонки 'Золотой работник'"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {}
        output_file = os.path.join(self.temp_dir, "output.xlsx")
        result = create_filtered_file(self.test_file, output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
        
        # Проверяем форматирование
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем цвета ячеек в колонке "Золотой работник"
        # Строка 2 (данные): "да" -> зеленый
        cell = ws['B2']
        self.assertEqual(cell.fill.start_color.index, '96C850')
        
        # Строка 3: "нет" -> красный
        cell = ws['B3']
        self.assertEqual(cell.fill.start_color.index, 'FF5050')
        
        # Строка 4: "запланирован" -> красный
        cell = ws['B4']
        self.assertEqual(cell.fill.start_color.index, 'FF5050')
        
        # Строка 5: "пробел" -> красный
        cell = ws['B5']
        self.assertEqual(cell.fill.start_color.index, 'FF5050')
        
        # Строка 6: "другое значение" -> без заливки
        cell = ws['B6']
        self.assertEqual(cell.fill.start_color.index, '00000000')  # Прозрачный цвет
    
    def test_golden_worker_case_insensitivity(self):
        """Проверяет обработку регистра в названии колонки и значениях"""
        # Создаем файл с разным регистром
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "TestSheet"
        
        # Добавляем заголовки с разным регистром
        ws.append(["ID", "ЗОЛОТОЙ РАБОТНИК", "Category"])
        
        # Добавляем данные с разным регистром
        ws.append([1, "ДА", "A"])
        ws.append([2, "НЕТ", "B"])
        ws.append([3, "ЗАПЛАНИРОВАН", "A"])
        ws.append([4, "ПРОБЕЛ", "B"])
        
        # Сохраняем файл
        test_file = os.path.join(self.temp_dir, "test_case_insensitive.xlsx")
        wb.save(test_file)
        
        sheet_headers = get_all_sheets_headers(test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {}
        output_file = os.path.join(self.temp_dir, "output_case.xlsx")
        result = create_filtered_file(test_file, output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
        
        # Проверяем форматирование
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем цвета ячеек
        # Строка 2: "ДА" -> зеленый
        cell = ws['B2']
        self.assertEqual(cell.fill.start_color.index, '96C850')
        
        # Строка 3: "НЕТ" -> красный
        cell = ws['B3']
        self.assertEqual(cell.fill.start_color.index, 'FF5050')
        
        # Строка 4: "ЗАПЛАНИРОВАН" -> красный
        cell = ws['B4']
        self.assertEqual(cell.fill.start_color.index, 'FF5050')
        
        # Строка 5: "ПРОБЕЛ" -> красный
        cell = ws['B5']
        self.assertEqual(cell.fill.start_color.index, 'FF5050')
    
    def test_golden_worker_in_middle(self):
        """Проверяет форматирование когда 'Золотой работник' не первая колонка"""
        # Создаем файл с колонкой в середине
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "TestSheet"
        
        # Добавляем заголовки
        ws.append(["ID", "Name", "Золотой работник", "Category"])
        
        # Добавляем данные
        ws.append([1, "John", "да", "A"])
        ws.append([2, "Jane", "нет", "B"])
        
        # Сохраняем файл
        test_file = os.path.join(self.temp_dir, "test_middle.xlsx")
        wb.save(test_file)
        
        sheet_headers = get_all_sheets_headers(test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {}
        output_file = os.path.join(self.temp_dir, "output_middle.xlsx")
        result = create_filtered_file(test_file, output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
        
        # Проверяем форматирование
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем цвета ячеек
        # Строка 2: "да" -> зеленый
        cell = ws['C2']
        self.assertEqual(cell.fill.start_color.index, '96C850')
        
        # Строка 3: "нет" -> красный
        cell = ws['C3']
        self.assertEqual(cell.fill.start_color.index, 'FF5050')

─── FILE: tests\test_table_formatting.py ───

import unittest
import os
import tempfile
import openpyxl
from excel_utils.workbook import create_filtered_file, clean_table_name
from excel_utils.analysis import get_all_sheets_headers

class TestTableFormatting(unittest.TestCase):
    def setUp(self):
        # Создаем тестовый Excel-файл
        self.temp_dir = tempfile.mkdtemp()
        self.test_file = os.path.join(self.temp_dir, "test_table.xlsx")
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "TestSheet"
        
        # Добавляем технические строки
        ws.append(["Technical info 1"])
        ws.append(["Technical info 2"])
        
        # Добавляем заголовки
        ws.append(["ID", "Value", "Category"])
        
        # Добавляем данные
        for i in range(1, 11):
            ws.append([i, i*10, "A" if i % 2 == 0 else "B"])
        
        wb.save(self.test_file)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_table_range(self):
        """Проверяет, что таблица создается только для данных, без технических строк"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {}
        output_file = os.path.join(self.temp_dir, "output.xlsx")
        result = create_filtered_file(self.test_file, output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
        
        # Проверяем, что таблица создана
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем, что таблица создана и имеет правильный диапазон
        self.assertTrue(len(ws.tables) > 0)
        table = list(ws.tables.values())[0]
        
        # Проверяем, что таблица начинается с строки заголовков (строка 3)
        self.assertEqual(table.ref[0], 'A')
        self.assertEqual(table.ref[1], '3')
        
        # Проверяем, что таблица заканчивается на последней строке данных (строка 12)
        last_row = int(table.ref.split(':')[1][1:])
        self.assertEqual(last_row, 12)
    
    def test_table_name_cleaning(self):
        """Проверяет, что имена таблиц не содержат пробелов"""
        # Проверка функции очистки имени
        self.assertEqual(clean_table_name("Sheet 1"), "Sheet1")
        self.assertEqual(clean_table_name("Таблица с пробелами"), "Таблицаспробелами")
        self.assertEqual(clean_table_name("Table@Name"), "TableName")
        self.assertEqual(clean_table_name("Table!Name"), "TableName")
        
        # Проверка, что имя таблицы не содержит пробелов
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {}
        output_file = os.path.join(self.temp_dir, "output.xlsx")
        result = create_filtered_file(self.test_file, output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
        
        # Проверяем имя таблицы
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем, что таблица создана
        self.assertTrue(len(ws.tables) > 0)
        
        # Проверяем, что имя таблицы не содержит пробелов
        table = list(ws.tables.values())[0]
        self.assertEqual(table.name, "TableTestSheet")
    
    def test_table_with_filtering(self):
        """Проверяет создание таблицы при фильтрации данных"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем фильтр для категории A
        filters = {"Category": "A"}
        output_file = os.path.join(self.temp_dir, "output_filtered.xlsx")
        result = create_filtered_file(self.test_file, output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
        
        # Проверяем, что таблица создана
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем, что таблица создана
        self.assertTrue(len(ws.tables) > 0)
        
        # Проверяем, что таблица имеет правильный диапазон
        table = list(ws.tables.values())[0]
        
        # Проверяем, что таблица начинается с строки заголовков (строка 3)
        self.assertEqual(table.ref[0], 'A')
        self.assertEqual(table.ref[1], '3')
        
        # Проверяем, что таблица заканчивается на последней строке данных (строка 8 для категории A)
        last_row = int(table.ref.split(':')[1][1:])
        self.assertEqual(last_row, 8)
    
    def test_table_with_no_extra_columns(self):
        """Проверяет, что таблица не захватывает лишние колонки"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {}
        output_file = os.path.join(self.temp_dir, "output.xlsx")
        result = create_filtered_file(self.test_file, output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
        
        # Проверяем, что таблица создана
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем, что таблица создана
        self.assertTrue(len(ws.tables) > 0)
        
        # Проверяем, что таблица не захватывает лишние колонки
        table = list(ws.tables.values())[0]
        last_col = table.ref.split(':')[1][0]
        self.assertEqual(last_col, 'C')  # Последняя колонка должна быть C, так как у нас 3 колонки
    
    def test_table_with_long_name(self):
        """Проверяет создание таблицы с длинным именем листа"""
        # Создаем файл с длинным именем листа
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "Very Long Sheet Name With Spaces And Special Characters!"
        
        # Добавляем заголовки
        ws.append(["ID", "Value", "Category"])
        
        # Добавляем данные
        ws.append([1, 10, "A"])
        
        # Сохраняем файл
        test_file = os.path.join(self.temp_dir, "test_long_name.xlsx")
        wb.save(test_file)
        
        sheet_headers = get_all_sheets_headers(test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {}
        output_file = os.path.join(self.temp_dir, "output_long.xlsx")
        result = create_filtered_file(test_file, output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
        
        # Проверяем, что таблица создана
        wb = openpyxl.load_workbook(result)
        ws = wb["Very Long Sheet Name With Spaces And Special Characters!"]
        
        # Проверяем, что таблица создана
        self.assertTrue(len(ws.tables) > 0)
        
        # Проверяем имя таблицы
        table = list(ws.tables.values())[0]
        # Убедимся, что имя таблицы очищено от недопустимых символов
        self.assertNotIn(' ', table.name)
        self.assertNotIn('!', table.name)
        self.assertEqual(table.name[:5], "Table")  # Имя должно начинаться с "Table"

─── FILE: tests\__init__.py ───


