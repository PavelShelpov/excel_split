=== PROJECT STRUCTURE ===

./
├── config.py
├── iteration_log.txt
├── logging_config.py
├── main.py
├── cli/
│   ├── interface.py
│   ├── __init__.py
├── core/
│   ├── processing.py
│   ├── __init__.py
├── excel_utils/
│   ├── analysis.py
│   ├── common.py
│   ├── filtering.py
│   ├── formatting.py
│   ├── workbook.py
│   ├── __init__.py
├── gui/
│   ├── placeholder.py
│   ├── __init__.py
├── tests/
│   ├── test_analysis.py
│   ├── test_filename_shortening.py
│   ├── test_filtering.py
│   ├── test_imports.py
│   ├── test_module_initialization.py
│   ├── test_special_formats.py
│   ├── test_table_formatting.py
│   ├── __init__.py


=== FILE CONTENTS ===


─── FILE: config.py ───

# Конфигурация проекта
# Будет расширена в будущих итерациях

MAX_SCAN_ROWS = 10
DEFAULT_FILE_EXTENSION = '.xlsx'


─── FILE: logging_config.py ───

import logging
import sys

def setup_logging():
    """Настраивает систему логирования для приложения."""
    logger = logging.getLogger('excel_splitter')
    logger.setLevel(logging.INFO)
    
    # Проверяем, не добавлены ли уже обработчики
    if not logger.handlers:
        # Создаем обработчик для вывода в консоль
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(logging.INFO)
        
        # Формат логов
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        console_handler.setFormatter(formatter)
        
        # Добавляем обработчик
        logger.addHandler(console_handler)
    
    return logger

# Создаем глобальный логгер
logger = setup_logging()

─── FILE: main.py ───

import sys
from logging_config import logger  # Импортируем уже настроенный логгер
from cli.interface import main as cli_main

def run():
    """Точка входа в приложение. Может быть расширена для поддержки GUI в будущем"""
    logger.info("Application started")
    cli_main()
    
def check_dependencies():
    try:
        import openpyxl
        version = openpyxl.__version__
        # Проверяем минимальную версию
        major, minor, _ = map(int, version.split('.'))
        if major < 3:
            logger.error("OpenPyXL version 3.0+ is required. Current version: %s", version)
            return False
        return True
    except ImportError:
        logger.error("OpenPyXL is not installed. Please install it with 'pip install openpyxl'")
        return False

if __name__ == "__main__":
    try:
        if check_dependencies():
            run()
    except Exception as e:
        logger.exception("Critical error in application")
        sys.exit(1)

─── FILE: cli\interface.py ───

from core.processing import process_file

def main():
    """Главный цикл программы: обработка файлов."""
    while True:
        success = process_file()
        # Спрашиваем, хочет ли пользователь продолжить
        if success:
            cont = input("\nDo you want to process another file? (y/n): ").strip().lower()
            if cont != 'y':
                print("Program terminated by user")
                break
        else:
            cont = input("\nDo you want to try again? (y/n): ").strip().lower()
            if cont != 'y':
                print("Program terminated by user")
                break

─── FILE: cli\__init__.py ───

# Импорты для пакета cli
from .interface import main

__all__ = ['main']

─── FILE: core\processing.py ───

import os
import logging
# Импортируем уже настроенный логгер из logging_config
from logging_config import logger
from excel_utils.analysis import get_all_sheets_headers, analyze_column
from excel_utils.filtering import get_all_combinations, select_categories_sequentially
from excel_utils.formatting import sanitize_filename, generate_short_filename
from excel_utils.workbook import create_filtered_file

def process_file():
    """Обрабатывает один файл: выбор файла, директории, колонок, категорий, создание файлов."""
    logger.info("Starting file processing")
    print("\n=== Copy Excel File ===")
    print("To cancel the operation, press Ctrl+C at any time")
    try:
        # Шаг 0: Выбор исходного файла
        while True:
            source = input("\nEnter full path to source Excel file: ").strip('"')
            if source.lower() == "cancel":
                print("Operation cancelled by user")
                return False
            if os.path.exists(source) and os.path.isfile(source):
                # Проверка формата файла
                if not (source.lower().endswith('.xlsx') or source.lower().endswith('.xlsm')):
                    print("Error: File must have .xlsx or .xlsm extension")
                    continue
                break
            print(f"Error: Source file not found or is not a file: {source}")
        
        # Шаг 1: Выбор целевой директории
        while True:
            destination = input("Enter target directory path: ").strip('"')
            if destination.lower() == "cancel":
                print("Operation cancelled by user")
                return False
            if os.path.isdir(destination):
                break
            print(f"Error: Target directory does not exist: {destination}")
        
        # Анализ Excel: заголовки во всех листах
        sheet_headers = get_all_sheets_headers(source)
        valid_sheets = {sheet: data for sheet, data in sheet_headers.items() if data[0] is not None}
        if not valid_sheets:
            logger.error("No headers found in any sheet")
            print("Error: No headers found in any sheet")
            return False
        
        # Поиск пересечения заголовков
        all_headers = [set(headers) for headers, _ in valid_sheets.values()]
        common_headers = set.intersection(*all_headers) if all_headers else set()
        if not common_headers:
            logger.warning("No common headers found between sheets")
            print("\nWarning: No common headers found between sheets")
            return False
        
        # Шаг 2: Выбор колонок для фильтрации
        print("\nAvailable columns for filtering:")
        common_headers_list = list(common_headers)
        for i, col in enumerate(common_headers_list, 1):
            print(f"  {i}. {col}")
        print("  b. Назад")
        print("  c. Отмена")
        while True:
            columns_input = input("Enter columns for filtering (comma-separated numbers or names): ").strip()
            if columns_input.lower() in ["c", "cancel", "отмена"]:
                print("Operation cancelled by user")
                return False
            if columns_input.lower() in ["b", "back", "назад"]:
                return False  # Возврат к началу
            # Обработка номеров колонок
            hierarchy_columns = []
            invalid_inputs = []
            for item in columns_input.split(","):
                item = item.strip()
                if item.isdigit():
                    idx = int(item) - 1
                    if 0 <= idx < len(common_headers_list):
                        hierarchy_columns.append(common_headers_list[idx])
                    else:
                        invalid_inputs.append(item)
                else:
                    hierarchy_columns.append(item)
            # Проверка валидности
            invalid_columns = [col for col in hierarchy_columns if col not in common_headers]
            if invalid_columns or invalid_inputs:
                invalid_list = invalid_columns + invalid_inputs
                print(f"Error: Invalid columns: {', '.join(invalid_list)}")
                continue
            if not hierarchy_columns:
                print("Error: No valid columns selected")
                continue
            break
        
        # Шаг 3: Последовательный выбор категорий
        print("\nStarting sequential category selection...")
        all_combinations = select_categories_sequentially(source, valid_sheets, hierarchy_columns)
        if not all_combinations:
            print("No combinations selected")
            return False
        
        # Создание файлов
        os.makedirs(destination, exist_ok=True)
        base_name = os.path.splitext(os.path.basename(source))[0]
        created_files = []
        for filters in all_combinations:
            # Формируем имя файла с расширением .xlsx
            short_filename = generate_short_filename(
                os.path.join(destination, base_name),
                filters
            )
            target_file = os.path.join(destination, short_filename)
            
            # Создаем файл
            created_file = create_filtered_file(source, target_file, valid_sheets, filters)
            if created_file is not None:
                created_files.append(created_file)
        
        # Вывод результатов
        if created_files:
            print(f"\nCreated {len(created_files)} files:")
            for file in created_files:
                print(f"  - {file}")
        else:
            print("Warning: No files created (no data matched the filters)")
        return True
    except KeyboardInterrupt:
        logger.info("Operation cancelled by user (Ctrl+C)")
        print("\nOperation cancelled by user (Ctrl+C)")
        return False
    except Exception as e:
        logger.exception("Unexpected error during file processing")
        print(f"Error: {str(e)}")
        return False

─── FILE: core\__init__.py ───

# Импорты для пакета core
from .processing import process_file

__all__ = ['process_file']

─── FILE: excel_utils\analysis.py ───

from contextlib import contextmanager
import openpyxl
from .common import validate_row
import logging

logger = logging.getLogger('excel_splitter')

@contextmanager
def safe_workbook(file_path, read_only=False):
    """Контекстный менеджер для безопасной работы с файлами Excel."""
    wb = None
    try:
        wb = openpyxl.load_workbook(file_path, read_only=read_only)
        yield wb
    finally:
        if wb:
            try:
                wb.close()
            except Exception as e:
                logger.error(f"Error closing workbook: {str(e)}")

def get_all_sheets_headers(file_path, max_scan_rows=10):
    """Анализирует все ВИДИМЫЕ листы в Excel-файле, возвращает заголовки для каждого."""
    logger.info(f"Analyzing headers in {file_path}")
    try:
        with safe_workbook(file_path, read_only=True) as wb:
            sheet_results = {}
            for ws in wb.worksheets:
                # Игнорируем скрытые листы
                if ws.sheet_state != 'visible':
                    continue
                max_non_empty = 0
                header_row = None
                header_row_idx = 0
                for row_idx, row in enumerate(ws.iter_rows(min_row=1, max_row=max_scan_rows), start=1):
                    non_empty_count = sum(1 for cell in row if cell.value is not None)
                    if non_empty_count > max_non_empty:
                        max_non_empty = non_empty_count
                        header_row = row
                        header_row_idx = row_idx
                if max_non_empty > 0:
                    headers = [cell.value for cell in header_row if cell.value is not None]
                    sheet_results[ws.title] = (headers, header_row_idx)
                    logger.debug(f"Found headers in sheet {ws.title}: {headers}")
                else:
                    sheet_results[ws.title] = (None, None)
            return sheet_results
    except Exception as e:
        logger.error(f"Error analyzing Excel: {str(e)}")
        raise ValueError(f"Error analyzing Excel: {str(e)}")

def analyze_column(file_path, valid_sheets, selected_column, filters=None):
    """Собирает уникальные значения из указанной колонки с учетом фильтров."""
    if filters is None:
        filters = {}
    logger.info(f"Analyzing column {selected_column} with filters {filters}")
    try:
        with safe_workbook(file_path, read_only=True) as wb:
            categories = set()
            for sheet_name, (headers, row_idx) in valid_sheets.items():
                ws = wb[sheet_name]
                try:
                    col_index = headers.index(selected_column)
                except ValueError:
                    continue
                for row in ws.iter_rows(min_row=row_idx + 1, values_only=True):
                    if not validate_row(row, headers, row_idx, filters):
                        continue
                    cell_value = row[col_index] if col_index < len(row) else None
                    if cell_value is not None and str(cell_value).strip() != "":
                        categories.add(str(cell_value).strip())
            return sorted(categories)
    except Exception as e:
        logger.error(f"Error analyzing data: {str(e)}")
        raise ValueError(f"Error analyzing data: {str(e)}")

─── FILE: excel_utils\common.py ───

import logging
logger = logging.getLogger('excel_splitter')

def validate_row(row, headers, header_row_idx, filters):
    """Проверяет соответствие строки условиям фильтров."""
    logger.debug(f"Validating row: {row}, headers: {headers}, filters: {filters}")
    
    if not filters:
        logger.debug("No filters provided, row is valid")
        return True
        
    # Нормализуем заголовки к нижнему регистру
    normalized_headers = [str(header).lower() if header is not None else "" for header in headers]
    
    for col, value in filters.items():
        # Нормализуем имя колонки к нижнему регистру
        normalized_col = str(col).lower()
        
        try:
            col_index = normalized_headers.index(normalized_col)
            cell_value = row[col_index] if col_index < len(row) else None
            str_value = str(cell_value).strip() if cell_value is not None else ""
            str_filter = str(value).strip()
            
            logger.debug(f"Checking column '{col}': cell value='{str_value}', filter='{str_filter}'")
            
            # Сравниваем без учета регистра
            if str_value.lower() != str_filter.lower():
                logger.debug(f"Row does not match filter for column '{col}'")
                return False
        except ValueError:
            logger.warning(f"Column '{col}' not found in headers")
            return False
    
    logger.debug("Row matches all filters")
    return True

─── FILE: excel_utils\filtering.py ───

from .analysis import analyze_column
import logging

logger = logging.getLogger('excel_splitter')

def get_all_combinations(source, valid_sheets, hierarchy_columns, filters=None, level=0):
    """Возвращает все возможные комбинации фильтров, включая частичные уровни."""
    if filters is None:
        filters = {}
    if level >= len(hierarchy_columns):
        return [filters.copy()]
    column = hierarchy_columns[level]
    logger.debug(f"Getting categories for column {column} with filters {filters}")
    categories = analyze_column(source, valid_sheets, column, filters)
    combinations = []
    # Добавляем комбинации для текущего уровня без добавления следующих уровней
    for category in categories:
        new_filters = filters.copy()
        new_filters[column] = category
        combinations.append(new_filters.copy())
    # Добавляем комбинации для следующих уровней
    for category in categories:
        new_filters = filters.copy()
        new_filters[column] = category
        combinations.extend(get_all_combinations(source, valid_sheets, hierarchy_columns, new_filters, level + 1))
    return combinations

def select_categories_sequentially(source, valid_sheets, hierarchy_columns):
    """Последовательно запрашивает выбор категорий у пользователя с отображением вариантов для каждой комбинации."""
    logger.info("Starting sequential category selection")
    all_combinations = []
    
    def generate_combinations(level, current_filters, include_all=False):
        if level >= len(hierarchy_columns):
            all_combinations.append(current_filters.copy())
            return
        column = hierarchy_columns[level]
        categories = analyze_column(source, valid_sheets, column, current_filters)
        if not categories:
            return
        # Проверяем, является ли текущий уровень последним
        is_last_level = (level == len(hierarchy_columns) - 1)
        # Если это не первый уровень и есть предыдущие фильтры
        if level > 0:
            logger.debug(f"Current filters: {current_filters}")
            print(f"\nCurrent filters:")
            for col, value in current_filters.items():
                print(f"  - {col}: {value}")
            # Если не последний уровень, спрашиваем, хочет ли пользователь выбрать все комбинации
            if not is_last_level:
                while True:
                    all_comb = input(f"Include all categories from '{hierarchy_columns[level]}' for current filters? (y/n): ").strip().lower()
                    if all_comb == 'y':
                        # Анализируем все возможные комбинации
                        for category in categories:
                            new_filters = current_filters.copy()
                            new_filters[column] = category
                            generate_combinations(level + 1, new_filters, True)
                        return
                    elif all_comb == 'n':
                        break
                    else:
                        print("Please enter 'y' or 'n'")
        # Выводим доступные категории с номерами
        print(f"\nAvailable categories for column '{column}':")
        for i, cat in enumerate(categories, 1):
            print(f"  {i}. {cat}")
        print("  b. Назад")
        print("  c. Отмена")
        # Запрашиваем выбор
        while True:
            selection = input(f"Enter categories for '{column}' (comma-separated numbers, 'all', 'b' for back, 'c' for cancel): ").strip()
            # Обработка специальных команд
            if selection.lower() in ["c", "cancel", "отмена"]:
                print("Operation cancelled by user")
                return
            if selection.lower() in ["b", "back", "назад"]:
                return
            # Обработка "all" - выбираем все категории
            if selection.lower() == "all":
                selected_categories = categories
                break
            # Обработка номеров
            user_categories = []
            invalid_inputs = []
            for item in selection.split(","):
                item = item.strip()
                if item.isdigit():
                    idx = int(item) - 1
                    if 0 <= idx < len(categories):
                        user_categories.append(categories[idx])
                    else:
                        invalid_inputs.append(item)
                else:
                    user_categories.append(item)
            # Проверка валидности
            invalid_categories = [cat for cat in user_categories if cat not in categories]
            if invalid_categories or invalid_inputs:
                invalid_list = invalid_categories + invalid_inputs
                print(f"Error: Invalid categories: {', '.join(invalid_list)}")
                continue
            selected_categories = user_categories
            break
        # Обрабатываем выбор
        for category in selected_categories:
            new_filters = current_filters.copy()
            new_filters[column] = category
            # Если пользователь выбрал "all" для предыдущего уровня
            if include_all and level > 0:
                generate_combinations(level + 1, new_filters, True)
            else:
                generate_combinations(level + 1, new_filters)
    
    # Начинаем генерацию комбинаций с первого уровня
    generate_combinations(0, {})
    # Добавляем частичные уровни фильтрации
    final_combinations = []
    for filters in all_combinations:
        # Добавляем фильтры всех подуровней
        for i in range(len(hierarchy_columns)):
            partial_filter = {}
            for j in range(i + 1):
                if hierarchy_columns[j] in filters:
                    partial_filter[hierarchy_columns[j]] = filters[hierarchy_columns[j]]
            final_combinations.append(partial_filter)
    # Удаляем дубликаты частичных фильтров
    unique_combinations = []
    seen = set()
    for filters in final_combinations:
        filter_tuple = tuple(sorted(filters.items()))
        if filter_tuple not in seen:
            seen.add(filter_tuple)
            unique_combinations.append(filters)
    return unique_combinations

─── FILE: excel_utils\formatting.py ───

import re
import os
import logging
from openpyxl.utils import get_column_letter
logger = logging.getLogger('excel_splitter')

def sanitize_filename(name):
    """Удаляет недопустимые символы из названия файла."""
    # Удаляем недопустимые символы
    name = re.sub(r'[\\/*?:"<>|]', '_', name)
    # Убираем лишние пробелы
    name = re.sub(r'\s+', ' ', name).strip()
    return name

def shorten_category_name(name):
    """
    Сокращает длинные названия категорий по правилам:
    - Для одного слова: первые 2 буквы, первая заглавная, вторая строчная
    - Для двух и более слов: первая буква первого слова в верхнем регистре, 
      вторая буква первого слова в нижнем регистре, первая буква второго слова в верхнем регистре
    """
    if not name:
        return ""
    
    # Удаляем недопустимые символы
    name = sanitize_filename(name)
    # Нормализуем пробелы
    name = re.sub(r'\s+', ' ', name).strip()
    
    # Если название короткое, оставляем как есть
    if len(name) <= 3:
        return name
    
    # Разбиваем на слова
    words = name.split()
    if len(words) > 1:
        # Для двух и более слов
        first_word = words[0]
        second_word = words[1] if len(words) > 1 else ""
        
        # Формируем сокращение: первая буква первого слова (заглавная), 
        # вторая буква первого слова (строчная), первая буква второго слова (заглавная)
        short_name = ""
        if len(first_word) > 0:
            short_name += first_word[0].upper()
        if len(first_word) > 1:
            short_name += first_word[1].lower()
        if len(second_word) > 0:
            short_name += second_word[0].upper()
        
        # Если не получилось сократить до 3 символов, берем первые 3 буквы
        if len(short_name) < 3:
            short_name = name[:3].upper()
    else:
        # Для одного слова
        short_name = name[:2]
        if len(short_name) == 1:
            short_name = short_name.upper()
        elif len(short_name) == 2:
            short_name = short_name[0].upper() + short_name[1].lower()
    
    return short_name

def generate_short_filename(base_name, filters, max_length=150):
    """
    Генерирует короткое имя файла с учетом максимальной длины.
    Если длина превышает max_length, использует хэш для уникальности.
    """
    # Создаем список сокращенных названий категорий
    safe_parts = []
    for i, (col, value) in enumerate(filters.items()):
        if i == len(filters) - 1:  # Последняя категория - не сокращаем
            safe_parts.append(sanitize_filename(value))
        else:
            safe_parts.append(shorten_category_name(value))
    
    # Формируем суффикс
    suffix = "_".join(safe_parts) if safe_parts else "All"
    
    # Проверяем длину полного пути
    full_path = os.path.join(os.path.dirname(base_name), f"{os.path.basename(base_name)}_{suffix}.xlsx")
    
    # Если длина слишком большая, сокращаем
    if len(full_path) > max_length:
        logger.warning(f"Filename is too long ({len(full_path)} characters), shortening...")
        
        # Оставляем только последние N символов из суффикса
        max_suffix_length = max_length - len(base_name) - 5  # Учитываем '.xlsx' и '_'
        
        if max_suffix_length <= 0:
            # Если даже базовое имя слишком длинное, используем хэш
            import hashlib
            hash_suffix = hashlib.sha1(suffix.encode()).hexdigest()[:8]
            suffix = f"short_{hash_suffix}"
        else:
            # Сокращаем суффикс до допустимой длины
            suffix = suffix[:max_suffix_length]
    
    return f"{os.path.basename(base_name)}_{suffix}.xlsx"

─── FILE: excel_utils\workbook.py ───

import os
import re
import logging
import openpyxl
from copy import copy
from contextlib import contextmanager
from openpyxl.worksheet.table import Table, TableStyleInfo
from excel_utils.common import validate_row
logger = logging.getLogger('excel_splitter')

def get_column_letter(col_idx):
    """Конвертирует индекс столбца в букву (1 -> A, 26 -> Z, 27 -> AA и т.д.)"""
    letters = []
    while col_idx > 0:
        col_idx, remainder = divmod(col_idx - 1, 26)
        letters.append(chr(65 + remainder))
    return ''.join(reversed(letters))

def is_openpyxl_new_version():
    """Проверяет, является ли версия openpyxl новой (>= 3.0)"""
    try:
        from openpyxl import __version__
        major_version = int(__version__.split('.')[0])
        return major_version >= 3
    except (ImportError, ValueError):
        return False

@contextmanager
def safe_workbook(file_path, read_only=False):
    """Контекстный менеджер для безопасной работы с файлами Excel."""
    wb = None
    try:
        logger.debug(f"Opening workbook: {file_path}")
        wb = openpyxl.load_workbook(file_path, read_only=read_only)
        yield wb
    finally:
        if wb:
            try:
                wb.close()
                logger.debug(f"Workbook closed: {file_path}")
            except Exception as e:
                logger.error(f"Error closing workbook: {str(e)}")

def create_filtered_file(source, target, valid_sheets, filters):
    """Создаёт файл с фильтрацией по комбинации условий."""
    logger.info(f"Creating filtered file: {target} with filters {filters}")
    
    # Добавлена проверка на пустой фильтр
    if not filters:
        logger.info("Empty filters, copying all data")
    
    try:
        # Всегда сохраняем как .xlsx
        if target.lower().endswith('.xlsm'):
            logger.debug("Converting .xlsm to .xlsx format")
            target = target[:-5] + '.xlsx'
        
        with safe_workbook(source, read_only=False) as wb_source:
            wb_new = openpyxl.Workbook()
            wb_new.remove(wb_new.active)
            has_data = False  # Флаг наличия данных
            logger.debug(f"Processing {len(wb_source.sheetnames)} sheets")
            
            for sheet_name in wb_source.sheetnames:
                ws_source = wb_source[sheet_name]
                # Игнорируем скрытые листы
                if ws_source.sheet_state != 'visible':
                    logger.debug(f"Skipping hidden sheet: {sheet_name}")
                    continue
                
                ws_new = wb_new.create_sheet(title=sheet_name)
                logger.debug(f"Processing sheet: {sheet_name}")
                
                # Копирование ширины столбцов
                if hasattr(ws_source, 'column_dimensions'):
                    for col_letter, dim in ws_source.column_dimensions.items():
                        try:
                            ws_new.column_dimensions[col_letter].width = dim.width
                        except Exception as e:
                            logger.debug(f"Error copying column width for {col_letter}: {str(e)}")
                
                # Копирование высоты строк
                if hasattr(ws_source, 'row_dimensions'):
                    for row_idx, dim in ws_source.row_dimensions.items():
                        try:
                            ws_new.row_dimensions[row_idx].height = dim.height
                        except Exception as e:
                            logger.debug(f"Error copying row height for {row_idx}: {str(e)}")
                
                # Копирование объединенных ячеек
                if hasattr(ws_source, 'merged_cells'):
                    for merged_cell in ws_source.merged_cells.ranges:
                        try:
                            ws_new.merge_cells(str(merged_cell))
                        except Exception as e:
                            logger.debug(f"Error copying merged cells: {str(e)}")
                
                # Копирование условного форматирования
                if hasattr(ws_source, 'conditional_formatting'):
                    for cf in ws_source.conditional_formatting:
                        try:
                            # Определяем, какой метод использовать для получения диапазона
                            range_attr = '_get_range' if hasattr(cf, '_get_range') else 'ref'
                            range_value = getattr(cf, range_attr, None) or cf._range
                            
                            # Определяем, какой тип правил используем
                            if hasattr(cf, 'cfRule') and hasattr(cf, 'cfRules'):
                                # Новые версии openpyxl
                                for rule in cf.cfRules:
                                    try:
                                        ws_new.conditional_formatting.add(range_value, rule)
                                    except Exception as e:
                                        logger.debug(f"Error adding rule in new format: {str(e)}")
                            elif hasattr(cf, 'rules'):
                                # Средние версии
                                for rule in cf.rules:
                                    try:
                                        ws_new.conditional_formatting.add(range_value, rule)
                                    except Exception as e:
                                        logger.debug(f"Error adding rule in medium format: {str(e)}")
                            else:
                                # Старые версии
                                try:
                                    ws_new.conditional_formatting.add(range_value, cf)
                                except Exception as e:
                                    logger.debug(f"Error adding rule in old format: {str(e)}")
                        except Exception as e:
                            logger.debug(f"Error copying conditional formatting: {str(e)}")
                
                if sheet_name in valid_sheets:
                    headers, header_row_idx = valid_sheets[sheet_name]
                    logger.debug(f"Headers for sheet {sheet_name}: {headers}")
                    logger.debug(f"Header row index: {header_row_idx}")
                    
                    # 1. Технические строки выше таблицы
                    for row_idx in range(1, header_row_idx):
                        for col_idx in range(1, ws_source.max_column + 1):
                            try:
                                cell = ws_source.cell(row=row_idx, column=col_idx)
                                if cell.value is not None or cell.has_style:
                                    new_cell = ws_new.cell(row=row_idx, column=col_idx, value=cell.value)
                                    if cell.has_style:
                                        # Копируем отдельные стили вместо общего
                                        try:
                                            new_cell.font = copy(cell.font)
                                            new_cell.border = copy(cell.border)
                                            new_cell.fill = copy(cell.fill)
                                            new_cell.alignment = copy(cell.alignment)
                                            new_cell.number_format = cell.number_format
                                        except Exception as e:
                                            logger.debug(f"Error copying individual style properties: {str(e)}")
                            except Exception as e:
                                logger.debug(f"Error copying cell at row {row_idx}, col {col_idx}: {str(e)}")
                    
                    # 2. Заголовки
                    for col_idx in range(1, ws_source.max_column + 1):
                        try:
                            cell = ws_source.cell(row=header_row_idx, column=col_idx)
                            if cell.value is not None or cell.has_style:
                                new_cell = ws_new.cell(row=header_row_idx, column=col_idx, value=cell.value)
                                if cell.has_style:
                                    # Копируем отдельные стили вместо общего
                                    try:
                                        new_cell.font = copy(cell.font)
                                        new_cell.border = copy(cell.border)
                                        new_cell.fill = copy(cell.fill)
                                        new_cell.alignment = copy(cell.alignment)
                                        new_cell.number_format = cell.number_format
                                    except Exception as e:
                                        logger.debug(f"Error copying individual style properties for header: {str(e)}")
                        except Exception as e:
                            logger.debug(f"Error copying header at col {col_idx}: {str(e)}")
                    
                    # 3. Фильтрация данных
                    new_row_idx = header_row_idx + 1
                    filtered_count = 0
                    for row_idx in range(header_row_idx + 1, ws_source.max_row + 1):
                        try:
                            row = ws_source[row_idx]
                            # Добавлена проверка на пустой фильтр
                            if not filters:
                                should_include = True
                            else:
                                should_include = validate_row([cell.value for cell in row], headers, header_row_idx, filters)
                            
                            if should_include:
                                filtered_count += 1
                                for col_idx in range(1, ws_source.max_column + 1):
                                    try:
                                        source_cell = ws_source.cell(row=row_idx, column=col_idx)
                                        if source_cell.value is not None or source_cell.has_style:
                                            new_cell = ws_new.cell(row=new_row_idx, column=col_idx, value=source_cell.value)
                                            if source_cell.has_style:
                                                # Копируем отдельные стили вместо общего
                                                try:
                                                    new_cell.font = copy(source_cell.font)
                                                    new_cell.border = copy(source_cell.border)
                                                    new_cell.fill = copy(source_cell.fill)
                                                    new_cell.alignment = copy(source_cell.alignment)
                                                    new_cell.number_format = source_cell.number_format
                                                except Exception as e:
                                                    logger.debug(f"Error copying individual style properties for data cell: {str(e)}")
                                    except Exception as e:
                                        logger.debug(f"Error copying data cell at row {row_idx}, col {col_idx}: {str(e)}")
                                new_row_idx += 1
                        except Exception as e:
                            logger.debug(f"Error processing row {row_idx}: {str(e)}")
                    
                    logger.debug(f"Filtered {filtered_count} rows out of {ws_source.max_row - header_row_idx} possible")
                    
                    # Проверка наличия данных
                    if new_row_idx > header_row_idx + 1:
                        has_data = True
                        # Форматируем данные как таблицу
                        last_col_letter = get_column_letter(ws_source.max_column)
                        # Исправлен диапазон таблицы
                        table_range = f"A{header_row_idx}:{last_col_letter}{new_row_idx-1}"
                        table = Table(displayName=f"Table{sheet_name}", ref=table_range)
                        
                        # Используем стандартный стиль таблицы
                        style = TableStyleInfo(
                            name="TableStyleLight1",
                            showFirstColumn=False,
                            showLastColumn=False,
                            showRowHeaders=True,
                            showColumnHeaders=True
                        )
                        
                        # Убедимся, что все заголовки таблицы - строки
                        headers_str = [str(h) if h is not None else "" for h in headers]
                        
                        table.tableStyleInfo = style
                        ws_new.add_table(table)
                    else:
                        # Удаляем лист без данных
                        wb_new.remove(ws_new)
                        logger.debug(f"Removed sheet {sheet_name} due to no matching data")
                        continue  # Переходим к следующему листу
                
                else:
                    logger.debug(f"Copying entire sheet {sheet_name} without filtering")
                    for row_idx in range(1, ws_source.max_row + 1):
                        for col_idx in range(1, ws_source.max_column + 1):
                            try:
                                cell = ws_source.cell(row=row_idx, column=col_idx)
                                if cell.value is not None or cell.has_style:
                                    new_cell = ws_new.cell(row=row_idx, column=col_idx, value=cell.value)
                                    if cell.has_style:
                                        # Копируем отдельные стили вместо общего
                                        try:
                                            new_cell.font = copy(cell.font)
                                            new_cell.border = copy(cell.border)
                                            new_cell.fill = copy(cell.fill)
                                            new_cell.alignment = copy(cell.alignment)
                                            new_cell.number_format = cell.number_format
                                        except Exception as e:
                                            logger.debug(f"Error copying individual style properties: {str(e)}")
                            except Exception as e:
                                logger.debug(f"Error copying cell at row {row_idx}, col {col_idx}: {str(e)}")
            
            if not has_data:
                logger.warning("No data matched the filters, file not created")
                return None
            
            # Удаляем целевой файл, если он существует
            if os.path.exists(target):
                logger.info(f"Removing existing target file: {target}")
                os.remove(target)
            
            # Сохраняем как .xlsx
            logger.info(f"Saving filtered file: {target}")
            wb_new.save(target)
            return target
    except Exception as e:
        logger.exception(f"Error during filtering: {str(e)}")
        raise ValueError(f"Error during filtering: {str(e)}")

─── FILE: excel_utils\__init__.py ───

# Импорты для пакета excel_utils
try:
    from .analysis import get_all_sheets_headers, analyze_column
    from .filtering import get_all_combinations, select_categories_sequentially
    from .formatting import sanitize_filename, generate_short_filename
    from .workbook import create_filtered_file
    from .common import validate_row
    
    __all__ = [
        'get_all_sheets_headers',
        'analyze_column',
        'get_all_combinations',
        'select_categories_sequentially',
        'sanitize_filename',
        'generate_short_filename',
        'create_filtered_file',
        'validate_row'
    ]
    
    # Убираем логгирование из __init__.py
    # Логгирование должно происходить в main.py после полной инициализации
except Exception as e:
    # Добавляем импорт logging ДО использования
    import logging
    logger = logging.getLogger('excel_splitter')
    logger.error(f"Failed to initialize excel_utils package: {str(e)}")
    raise

─── FILE: gui\placeholder.py ───

# Заглушка для будущего GUI
# В следующих итерациях будет заменена на реальную реализацию

def launch_gui():
    """Запуск графического интерфейса (заглушка)"""
    print("GUI is not implemented yet. Running CLI version instead.")
    from cli.interface import main
    main()

─── FILE: gui\__init__.py ───

# Импорты для пакета gui
from .placeholder import launch_gui

__all__ = ['launch_gui']

─── FILE: tests\test_analysis.py ───

import unittest
from excel_utils.analysis import get_all_sheets_headers, analyze_column
from excel_utils.common import validate_row
import os
import tempfile

class TestExcelAnalysis(unittest.TestCase):
    def setUp(self):
        # Создаем тестовый Excel-файл
        self.temp_dir = tempfile.mkdtemp()
        self.test_file = os.path.join(self.temp_dir, "test.xlsx")
        
        from openpyxl import Workbook
        wb = Workbook()
        ws = wb.active
        ws.title = "Sheet1"
        ws.append(["Header1", "Header2", "Header3"])
        ws.append(["Data1", "ValueA", "100"])
        ws.append(["Data2", "ValueB", "200"])
        ws.append(["Data3", "ValueA", "300"])
        wb.save(self.test_file)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_get_all_sheets_headers(self):
        """Проверяет корректность определения заголовков в Excel-файле"""
        headers = get_all_sheets_headers(self.test_file)
        self.assertIn("Sheet1", headers)
        self.assertEqual(headers["Sheet1"][0], ["Header1", "Header2", "Header3"])
    
    def test_analyze_column(self):
        """Проверяет сбор уникальных значений из колонки"""
        headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in headers.items() if v[0] is not None}
        
        categories = analyze_column(self.test_file, valid_sheets, "Header2")
        self.assertEqual(categories, ["ValueA", "ValueB"])
    
    def test_validate_row(self):
        """Проверяет фильтрацию строк по условиям"""
        headers = ["Header1", "Header2", "Header3"]
        row = ["Data1", "ValueA", "100"]
        
        # Проверяем фильтр по одной колонке
        self.assertTrue(validate_row(row, headers, 1, {"Header2": "ValueA"}))
        self.assertFalse(validate_row(row, headers, 1, {"Header2": "ValueB"}))
        
        # Проверяем фильтр по нескольким колонкам
        self.assertTrue(validate_row(row, headers, 1, {"Header1": "Data1", "Header2": "ValueA"}))
        self.assertFalse(validate_row(row, headers, 1, {"Header1": "Data1", "Header2": "ValueB"}))

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_filename_shortening.py ───

import unittest
import os
import tempfile
from excel_utils.formatting import sanitize_filename, shorten_category_name, generate_short_filename

class TestFilenameShortening(unittest.TestCase):
    def setUp(self):
        self.temp_dir = tempfile.mkdtemp()
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_sanitize_filename(self):
        """Проверяет удаление недопустимых символов из названия файла"""
        self.assertEqual(sanitize_filename("Test:File?Name*"), "Test_File_Name_")
        self.assertEqual(sanitize_filename("File with spaces"), "File with spaces")
        self.assertEqual(sanitize_filename("File<>|"), "File____")
    
    def test_shorten_category_name(self):
        """Проверяет сокращение длинных названий категорий"""
        # Тест с коротким именем
        self.assertEqual(shorten_category_name("IT"), "IT")
        
        # Тест с одним длинным словом
        self.assertEqual(shorten_category_name("Department"), "De")
        self.assertEqual(shorten_category_name("A"), "A")
        self.assertEqual(shorten_category_name("Ab"), "Ab")
        self.assertEqual(shorten_category_name("Abc"), "Ab")
        
        # Тест с несколькими словами
        self.assertEqual(shorten_category_name("Human Resources"), "HuR")
        self.assertEqual(shorten_category_name("Apparatus Management"), "ApM")
        self.assertEqual(shorten_category_name("Apparatus Management Development"), "ApM")
        self.assertEqual(shorten_category_name("Apparatus Management Development Department"), "ApM")
    
    def test_generate_short_filename(self):
        """Проверяет генерацию коротких имен файлов"""
        # Базовый случай
        base_path = os.path.join(self.temp_dir, "base_file")
        filters = {
            "Department": "Human Resources",
            "Team": "Development",
            "Project": "New Project"
        }
        filename = generate_short_filename(base_path, filters)
        self.assertEqual(filename, "base_file_HuR_Dev_New Project.xlsx")
        
        # Сокращение для длинных имен
        base_path = os.path.join(self.temp_dir, "base_file")
        filters = {
            "Department": "Apparatus Management Development Department",
            "Team": "Development Team for New Projects"
        }
        filename = generate_short_filename(base_path, filters)
        self.assertEqual(filename, "base_file_ApM_DT.xlsx")
        
        # Проверка ограничения длины
        base_path = os.path.join(self.temp_dir, "very_long_base_name" * 10)
        filters = {
            "Department": "Very Long Department Name " * 10,
            "Team": "Very Long Team Name " * 10
        }
        filename = generate_short_filename(base_path, filters)
        self.assertTrue(len(filename) <= 200)
        
        # Проверка хэширования при очень длинных именах
        base_path = os.path.join(self.temp_dir, "a" * 200)
        filters = {
            "Department": "b" * 200,
            "Team": "c" * 200
        }
        filename = generate_short_filename(base_path, filters)
        self.assertIn("short_", filename)
        self.assertEqual(len(filename), 200)

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_filtering.py ───

import unittest
import os
import tempfile
from excel_utils.common import validate_row

class TestFiltering(unittest.TestCase):
    def test_validate_row_empty_filters(self):
        """Проверяет, что строка проходит валидацию без фильтров"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertTrue(validate_row(row, headers, 1, {}))
    
    def test_validate_row_single_filter_match(self):
        """Проверяет, что строка соответствует одиночному фильтру"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertTrue(validate_row(row, headers, 1, {"Category": "A"}))
    
    def test_validate_row_single_filter_no_match(self):
        """Проверяет, что строка не соответствует одиночному фильтру"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertFalse(validate_row(row, headers, 1, {"Category": "B"}))
    
    def test_validate_row_multiple_filters_match(self):
        """Проверяет, что строка соответствует нескольким фильтрам"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertTrue(validate_row(row, headers, 1, {"Name": "Item1", "Category": "A"}))
    
    def test_validate_row_multiple_filters_no_match(self):
        """Проверяет, что строка не соответствует нескольким фильтрам"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertFalse(validate_row(row, headers, 1, {"Name": "Item2", "Category": "A"}))
    
    def test_validate_row_missing_column(self):
        """Проверяет обработку отсутствующего столбца в фильтре"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertFalse(validate_row(row, headers, 1, {"NonExistent": "Value"}))
    
    def test_validate_row_with_none_values(self):
        """Проверяет обработку None значений"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", None, "A"]
        self.assertTrue(validate_row(row, headers, 1, {"Value": ""}))
    
    def test_validate_row_case_sensitivity(self):
        """Проверяет обработку регистра"""
        headers = ["Name", "Value", "Category"]
        row = ["Item1", "100", "A"]
        self.assertTrue(validate_row(row, headers, 1, {"category": "A"}))  # Строчные буквы в ключе

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_imports.py ───

import unittest
import sys
import os

# Добавляем корневую директорию проекта в путь для импорта
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

class TestModuleImports(unittest.TestCase):
    """Тест на проверку корректности импортов модулей"""
    
    def test_import_main(self):
        """Проверяет, что main.py импортируется без ошибок"""
        try:
            import main
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import main: {str(e)}")
    
    def test_import_cli(self):
        """Проверяет, что cli модуль импортируется без ошибок"""
        try:
            from cli import interface
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import cli: {str(e)}")
    
    def test_import_core(self):
        """Проверяет, что core модуль импортируется без ошибок"""
        try:
            from core import processing
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import core: {str(e)}")
    
    def test_import_excel_utils(self):
        """Проверяет, что excel_utils модуль импортируется без ошибок"""
        try:
            from excel_utils import (
                analysis, 
                filtering, 
                formatting, 
                workbook,
                get_all_sheets_headers,
                analyze_column,
                get_all_combinations,
                select_categories_sequentially,
                sanitize_filename,
                generate_short_filename,
                create_filtered_file
            )
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import excel_utils: {str(e)}")
    
    def test_import_specific_functions(self):
        """Проверяет доступность конкретных функций через пакетный импорт"""
        try:
            from excel_utils import (
                generate_short_filename,
                create_filtered_file
            )
            self.assertTrue(True)
        except Exception as e:
            self.fail(f"Failed to import specific functions: {str(e)}")

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_module_initialization.py ───

import unittest
import sys
import os
import logging

# Добавляем корневую директорию проекта в путь для импорта
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

class TestModuleInitialization(unittest.TestCase):
    """Тест на проверку корректной инициализации всех модулей"""
    
    def setUp(self):
        # Настройка логгера для тестов
        logging.basicConfig(level=logging.DEBUG)
        self.logger = logging.getLogger('test_initialization')
    
    def test_excel_utils_initialization(self):
        """Проверяет, что пакет excel_utils инициализируется без ошибок"""
        try:
            import excel_utils
            self.assertIsNotNone(excel_utils)
            self.logger.debug("excel_utils package imported successfully")
        except Exception as e:
            self.fail(f"Failed to import excel_utils package: {str(e)}")
    
    def test_all_modules_import(self):
        """Проверяет импорт всех модулей проекта"""
        modules = [
            'excel_utils.analysis',
            'excel_utils.filtering',
            'excel_utils.formatting',
            'excel_utils.workbook',
            'excel_utils.common',
            'core.processing',
            'cli.interface'
        ]
        
        for module in modules:
            try:
                __import__(module)
                self.logger.debug(f"Successfully imported {module}")
            except Exception as e:
                self.fail(f"Failed to import {module}: {str(e)}")
    
    def test_function_availability(self):
        """Проверяет доступность критических функций"""
        try:
            from excel_utils.formatting import generate_short_filename
            self.assertTrue(callable(generate_short_filename))
            
            from excel_utils.common import validate_row
            self.assertTrue(callable(validate_row))
            
            from excel_utils.workbook import create_filtered_file
            self.assertTrue(callable(create_filtered_file))
        except Exception as e:
            self.fail(f"Critical functions not available: {str(e)}")

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_special_formats.py ───

import unittest
import os
import tempfile
import openpyxl
from excel_utils.workbook import create_filtered_file
from excel_utils.analysis import get_all_sheets_headers
from excel_utils.common import validate_row

class TestSpecialFormats(unittest.TestCase):
    def setUp(self):
        # Создаем тестовый Excel-файл с особыми стилями и условным форматированием
        self.temp_dir = tempfile.mkdtemp()
        self.test_file = os.path.join(self.temp_dir, "test_special.xlsx")
        self.output_file = os.path.join(self.temp_dir, "output.xlsx")
        
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "TestSheet"
        
        # Добавляем заголовки
        ws.append(["ID", "Value", "Category"])
        
        # Добавляем данные
        for i in range(1, 11):
            ws.append([i, i*10, "A" if i % 2 == 0 else "B"])
        
        # Добавляем условное форматирование
        from openpyxl.formatting import Rule
        from openpyxl.formatting.rule import ColorScaleRule
        
        # Создаем правило условного форматирования
        rule = ColorScaleRule(
            start_type='min', start_color='FF0000',
            mid_type='percentile', mid_color='FFFF00',
            end_type='max', end_color='00FF00'
        )
        
        # Добавляем правило к диапазону
        ws.conditional_formatting.add('B2:B11', rule)
        
        # Добавляем специфический стиль (имитируем SAPBEXstdItem)
        from openpyxl.styles import NamedStyle
        sap_style = NamedStyle(name="SAPBEXstdItem")
        sap_style.font = openpyxl.styles.Font(bold=True)
        sap_style.fill = openpyxl.styles.PatternFill(start_color="00FF0000", end_color="00FF0000", fill_type="solid")
        
        # Применяем стиль к ячейке
        ws['A2'].style = sap_style
        
        wb.save(self.test_file)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_special_style_handling(self):
        """Проверяет обработку специфических стилей"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {"Category": "A"}
        
        # Пытаемся создать фильтрованный файл
        result = create_filtered_file(self.test_file, self.output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
    
    def test_conditional_formatting(self):
        """Проверяет копирование условного форматирования"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {"Category": "A"}
        
        # Пытаемся создать фильтрованный файл
        result = create_filtered_file(self.test_file, self.output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        
        # Проверяем, что условное форматирование присутствует в выходном файле
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем, что условное форматирование существует
        self.assertTrue(len(ws.conditional_formatting) > 0)
    
    def test_empty_filter(self):
        """Проверяет работу с пустым фильтром"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Пустой фильтр
        filters = {}
        
        # Пытаемся создать фильтрованный файл
        result = create_filtered_file(self.test_file, self.output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        
        # Проверяем, что все данные сохранены
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Должно быть 11 строк (заголовок + 10 данных)
        self.assertEqual(ws.max_row, 11)
    
    def test_no_matching_data(self):
        """Проверяет работу с фильтром, не находящим совпадений"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Фильтр, не должен находить совпадений
        filters = {"Category": "C"}
        
        # Пытаемся создать фильтрованный файл
        result = create_filtered_file(self.test_file, self.output_file, valid_sheets, filters)
        
        self.assertIsNone(result)
        self.assertFalse(os.path.exists(self.output_file))

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\test_table_formatting.py ───

import unittest
import os
import tempfile
import openpyxl
from excel_utils.workbook import create_filtered_file
from excel_utils.analysis import get_all_sheets_headers

class TestTableFormatting(unittest.TestCase):
    def setUp(self):
        # Создаем тестовый Excel-файл
        self.temp_dir = tempfile.mkdtemp()
        self.test_file = os.path.join(self.temp_dir, "test_table.xlsx")
        
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "TestSheet"
        
        # Добавляем заголовки
        ws.append(["ID", "Value", "Category"])
        
        # Добавляем данные
        for i in range(1, 11):
            ws.append([i, i*10, "A" if i % 2 == 0 else "B"])
        
        wb.save(self.test_file)
    
    def tearDown(self):
        import shutil
        shutil.rmtree(self.temp_dir)
    
    def test_table_creation(self):
        """Проверяет создание таблиц в результирующем файле"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем простой фильтр
        filters = {}
        
        output_file = os.path.join(self.temp_dir, "output.xlsx")
        result = create_filtered_file(self.test_file, output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
        
        # Проверяем, что таблица создана
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем, что есть таблица
        self.assertTrue(len(ws.tables) > 0)
        
        # Проверяем, что таблица имеет правильный диапазон
        table = list(ws.tables.values())[0]
        self.assertEqual(table.ref, "A1:C11")
    
    def test_table_with_filtering(self):
        """Проверяет создание таблицы при фильтрации данных"""
        sheet_headers = get_all_sheets_headers(self.test_file)
        valid_sheets = {k: v for k, v in sheet_headers.items() if v[0] is not None}
        
        # Создаем фильтр для категории A
        filters = {"Category": "A"}
        
        output_file = os.path.join(self.temp_dir, "output_filtered.xlsx")
        result = create_filtered_file(self.test_file, output_file, valid_sheets, filters)
        
        self.assertIsNotNone(result)
        self.assertTrue(os.path.exists(result))
        
        # Проверяем, что таблица создана
        wb = openpyxl.load_workbook(result)
        ws = wb["TestSheet"]
        
        # Проверяем, что есть таблица
        self.assertTrue(len(ws.tables) > 0)
        
        # Проверяем, что таблица имеет правильный диапазон
        table = list(ws.tables.values())[0]
        self.assertEqual(table.ref, "A1:C6")  # 1 заголовок + 5 строк данных

if __name__ == '__main__':
    unittest.main()

─── FILE: tests\__init__.py ───


