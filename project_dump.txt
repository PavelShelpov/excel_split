=== PROJECT STRUCTURE ===

./
├── file_handler.py
├── filter_logic.py
├── issues.txt
├── main.py
├── user_requirements.feature


=== FILE CONTENTS ===


─── FILE: file_handler.py ───

import pandas as pd

def load_xlsx(file_path: str) -> pd.DataFrame:
    """
    Загружает XLSX-файл в pandas DataFrame.

    :param file_path: Путь к XLSX-файлу.
    :return: Загруженный DataFrame.
    :raises: FileNotFoundError, ValueError (если файл не найден или имеет неверный формат).
    """
    try:
        df = pd.read_excel(file_path, engine='openpyxl')
        return df
    except FileNotFoundError:
        raise FileNotFoundError(f"Файл не найден: {file_path}")
    except Exception as e:
        # pandas может выбросить разные ошибки при чтении (например, xlrd в старых версиях)
        # Лучше уточнить тип ошибки, но для простоты - общий Exception
        raise ValueError(f"Ошибка при чтении файла: {e}")

def save_xlsx(dataframe: pd.DataFrame, output_path: str) -> None:
    """
    Сохраняет pandas DataFrame в XLSX-файл.

    :param dataframe: DataFrame для сохранения.
    :param output_path: Путь для сохранения XLSX-файла.
    """
    dataframe.to_excel(output_path, index=False, engine='openpyxl')

─── FILE: filter_logic.py ───

import pandas as pd

def get_column_names(dataframe: pd.DataFrame) -> list[str]:
    """
    Возвращает список названий колонок из DataFrame.

    :param dataframe: Входной DataFrame.
    :return: Список названий колонок.
    """
    return list(dataframe.columns)

def get_unique_values(dataframe: pd.DataFrame, column_name: str) -> list:
    """
    Возвращает уникальные значения (категории) в указанной колонке.

    :param dataframe: Входной DataFrame.
    :param column_name: Название колонки.
    :return: Список уникальных значений. Включает NaN, если они есть.
    """
    # Используем dropna=False, чтобы NaN оставались в списке уникальных значений,
    # если они присутствуют. Это позволяет пользователю их выбрать.
    # Если NaN не нужны, можно использовать dataframe[column_name].dropna().unique()
    unique_series = dataframe[column_name].unique()
    # Конвертируем numpy array в list для удобства
    return unique_series.tolist()

def apply_filter(dataframe: pd.DataFrame, column_name: str, category_value) -> pd.DataFrame:
    """
    Применяет фильтр к DataFrame по указанной колонке и значению категории.

    :param dataframe: Входной DataFrame.
    :param column_name: Название колонки для фильтрации.
    :param category_value: Значение категории для фильтрации.
    :return: Новый, отфильтрованный DataFrame.
    """
    # Используем .copy() для создания независимой копии отфильтрованных данных
    filtered_df = dataframe[dataframe[column_name] == category_value].copy()
    return filtered_df

─── FILE: issues.txt ───



─── FILE: main.py ───

import pandas as pd
from file_handler import load_xlsx, save_xlsx
from filter_logic import get_column_names, get_unique_values, apply_filter
import os
import unicodedata
import re

def clean_filename_part(name_part: str) -> str:
    """
    Очищает часть имени файла от недопустимых символов.
    """
    if not isinstance(name_part, str):
        name_part = str(name_part)
    # Нормализуем Unicode (опционально, для лучшей обработки символов)
    normalized = unicodedata.normalize('NFKD', name_part)
    # Удаляем или заменяем недопустимые символы
    safe_str = "".join(c for c in normalized if c.isalnum() or c in (' ', '-', '_', '.'))
    # Удаляем пробелы в начале и конце
    return safe_str.rstrip().lstrip()

def main():
    """
    Основная функция приложения для фильтрации XLSX файла по категориям в колонке.
    """
    print("--- Приложение фильтрации XLSX файла по категориям ---")

    # 1. Пользователь выбирает файл (ввод пути в консоли)
    file_path = input("Введите путь к XLSX файлу: ").strip()
    if not file_path:
        print("Путь к файлу не может быть пустым.")
        return

    # 2. Загрузка файла
    try:
        print(f"Загрузка файла: {file_path}")
        df = load_xlsx(file_path)
        print(f"Файл успешно загружен. Размер: {df.shape[0]} строк, {df.shape[1]} колонок.")
    except FileNotFoundError as fnf_error:
        print(fnf_error)
        return
    except ValueError as ve:
        print(ve)
        return
    except Exception as e:
        print(f"Произошла непредвиденная ошибка при загрузке: {e}")
        return

    # --- Нормализация имён колонок ---
    original_columns = get_column_names(df)
    # Функция нормализации для колонок
    def normalize_col_name(name: str) -> str:
        if not isinstance(name, str):
            name = str(name)
        normalized = unicodedata.normalize('NFKD', name)
        lower = normalized.lower()
        stripped = lower.strip()
        cleaned = re.sub(r'\s+', '', stripped)
        return cleaned

    # Создаём словарь для сопоставления нормализованного имени с оригинальным
    normalized_to_original = {normalize_col_name(col): col for col in original_columns}

    print("\nДоступные колонки:")
    for i, col in enumerate(original_columns):
        print(f"{i + 1}. {col}")

    selected_column = None
    while selected_column is None:
        try:
            col_choice = input("\nВведите номер или название колонки для фильтрации: ").strip()
            # Проверяем, является ли ввод числом и соответствует ли номер колонке
            if col_choice.isdigit():
                col_index = int(col_choice) - 1
                if 0 <= col_index < len(original_columns):
                    selected_column = original_columns[col_index]
                    break
                else:
                    print("Неверный номер колонки. Пожалуйста, попробуйте снова.")
            # Проверяем, является ли ввод названием колонки (с нормализацией)
            else:
                normalized_choice = normalize_col_name(col_choice)
                if normalized_choice in normalized_to_original:
                    selected_column = normalized_to_original[normalized_choice]
                    break
                else:
                    print("Колонка с таким названием не найдена. Пожалуйста, попробуйте снова.")
        except (ValueError, IndexError):
            print("Неверный ввод. Пожалуйста, введите номер или название колонки.")

    print(f"Выбрана колонка: '{selected_column}'")

    # 4. Получение всех уникальных значений (категорий) из выбранной колонки
    print(f"\nУникальные значения в колонке '{selected_column}':")
    unique_values = get_unique_values(df, selected_column)
    for i, val in enumerate(unique_values):
        # Отображаем NaN как строку 'NaN' для ясности ввода
        display_val = "NaN" if pd.isna(val) else val
        print(f"{i + 1}. {display_val}")

    # 5. Пользователю предлагается выбор: фильтровать по всем или нескольким категориям
    print("\n--- Выбор категорий для фильтрации ---")
    choice = None
    while choice not in ['все', 'несколько']:
        choice_input = input("Фильтровать по 'всем' категориям или 'несколько'? Введите 'все' или 'несколько': ").strip().lower()
        if choice_input in ['все', 'всем', 'all']:
            choice = 'все'
        elif choice_input in ['несколько', 'некоторые', 'several', 'some']:
            choice = 'несколько'
        else:
            print("Пожалуйста, введите 'все' или 'несколько'.")

    print(f"Выбран режим фильтрации: {choice}")

    # Определение списка категорий для фильтрации
    categories_to_filter = []
    if choice == 'все':
        categories_to_filter = unique_values
    else: # choice == 'несколько'
        selected_indices = set() # Используем set для уникальности
        print("\nВведите номера категорий для фильтрации (например, 1 3 5 или 1-3 5). Нажмите Enter, когда закончите:")
        while True:
            selection_input = input("Выберите номер(а) или диапазон(ы) через пробел (или Enter для завершения): ").strip()
            if not selection_input:
                break # Пользователь закончил ввод

            parts = selection_input.split()
            valid_selection = True
            for part in parts:
                if '-' in part:
                    # Обработка диапазона (например, 1-3)
                    try:
                        start, end = map(int, part.split('-'))
                        if start > end:
                            start, end = end, start # Поменять местами, если начальный больше
                        for num in range(start, end + 1):
                            idx = num - 1 # Индексация с 0
                            if 0 <= idx < len(unique_values):
                                selected_indices.add(idx)
                            else:
                                print(f"Номер {num} вне диапазона. Пропущен.")
                                valid_selection = False
                    except ValueError:
                        print(f"Неверный формат диапазона: {part}. Пропущен.")
                        valid_selection = False
                else:
                    # Обработка одиночного номера
                    try:
                        num = int(part)
                        idx = num - 1 # Индексация с 0
                        if 0 <= idx < len(unique_values):
                            selected_indices.add(idx)
                        else:
                            print(f"Номер {num} вне диапазона. Пропущен.")
                            valid_selection = False
                    except ValueError:
                        print(f"Неверный номер: {part}. Пропущен.")
                        valid_selection = False

            if not valid_selection:
                print("Пожалуйста, повторите ввод.")

        # Формирование списка выбранных категорий по индексам
        for idx in selected_indices:
            categories_to_filter.append(unique_values[idx])

        if not categories_to_filter:
            print("Не выбрано ни одной категории. Программа завершена.")
            return

        print(f"Выбраны следующие категории для фильтрации:")
        for cat in categories_to_filter:
            print(f" - {cat}")


    # 6. Цикл по выбранным уникальным значениям (категориям)
    print(f"\nНачинается процесс фильтрации по {len(categories_to_filter)} выбранной(ым) категории(ям)...")
    saved_files_count = 0
    used_filenames = set() # Отслеживаем уже использованные имена файлов
    for category_value in categories_to_filter:
        print(f"\nФильтрация по категории: '{category_value}'...")
        # 7. Фильтрация файла по текущей категории
        # Обработка NaN: pandas не может сравнить NaN с NaN через ==, используем pd.isna для фильтрации
        if pd.isna(category_value):
             # Используем pd.isna для фильтрации строк с NaN в выбранной колонке
            filtered_df = df[df[selected_column].isna()].copy()
            # Для имени файла используем строковое представление NaN
            category_str = "NaN"
        else:
            # Используем apply_filter из filter_logic.py для остальных случаев
            filtered_df = apply_filter(df, selected_column, category_value)
            # Используем строковое представление значения категории для имени файла
            category_str = str(category_value)

        print(f"  Найдено {filtered_df.shape[0]} строк для категории '{category_value}'.")

        # 8. Сохранение файла для текущей категории
        # Имя файла формируется на основе ОРИГИНАЛЬНОГО значения категории
        # Очищаем category_str от недопустимых символов
        safe_category_str = clean_filename_part(category_str)
        if not safe_category_str:
             # Если после очистки имя пустое, используем заглушку
            safe_category_str = "unnamed_category"

        # --- Исправление для уникальности имён файлов ---
        # Получаем имя исходного файла без расширения
        original_filename = os.path.splitext(os.path.basename(file_path))[0]
        base_output_filename = f"{original_filename}__{safe_category_str}.xlsx"
        output_filename = base_output_filename

        # Проверяем, существует ли такое имя уже, и если да, добавляем суффикс
        counter = 1
        while output_filename in used_filenames:
            name_part, ext_part = os.path.splitext(base_output_filename)
            output_filename = f"{name_part}_{counter}{ext_part}"
            counter += 1

        # Добавляем имя файла в список использованных
        used_filenames.add(output_filename)

        try:
            save_xlsx(filtered_df, output_filename)
            print(f"  Файл для категории '{category_value}' успешно сохранен как: {output_filename}")
            saved_files_count += 1
        except Exception as e:
            print(f"  Ошибка при сохранении файла для категории '{category_value}': {e}")

    print(f"\n--- Процесс завершен ---")
    print(f"Всего уникальных категорий в колонке '{selected_column}': {len(unique_values)}")
    print(f"Выбрано для фильтрации: {len(categories_to_filter)}")
    print(f"Успешно сохранено файлов: {saved_files_count}")

if __name__ == "__main__":
    main()

─── FILE: user_requirements.feature ───

Функция: Фильтрация файла по категории

    Сценарий: Фильтрация файла категориям
        Дано файл xlsx
        # выполняется
        Когда пользователь выбирает файл
        # выполняется
        Затем пользователю отображаются колонки из имеющихся в таблице
        # выполняется
        Затем пользователь выбирает колонку
        # выполняется
        Затем пользователю отображаются категории из колонки
        # выполняется
        И идентичные категории с символами в разных регистрах, разницей в пробелах, со спецсимволами отображаются как одна
        # не выполняется: отображаются как разные строки
        Затем пользователь выбирает категорию
        # выполняется
        Тогда пользователю предлагается выбор фильровать по всем категориям или нескольким
        # выполняется
        Затем файл фильтруется по выбору пользователя
        # выполняется
        Затем файл по каждой выбранной категории сохраняется
        # выполняется
        И каждому файлу задается имя его категории
        # выполняется
